## InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 5.5 부터는 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택됐지만, MySQL 서버의 시스템 테이블(사용자 인증 관련된 정보와 복제 관련된 정보가 저장된 mysql DB의 테이블)은 여전히 MyISAM 테이블을 사용했다. 또한 전문 검색이나 공간 좌표 검색 기능은 MyISAM 테이블에서만 지원됐다.

  

- MySQL 8.0으로 업그레이드되면서 MySQL 서버의 모든 시스템 테이블이 InnoDb 스토리지 엔진으로 교채되었고, 공간 좌표 검색이나 전문 검색 기능이 모두 InnoDB 스토리지 엔진을 지원하도록 개선되었다.

  - 8.0 버전부터는 MySQL 서버의 모든 기능을 InnoDB 스토리지 엔진만으로 구현할 수 있게 된 것이다.

    

- InnoDB 스토리지 엔진에 대한 기능이 개선되는 만큼 MyISAM 스토리지 엔진의 기능은 도태되는 상황이며, 이후 버전에서는 MyISAM 스토리지 엔진은 없어질 것으로 예상한다.

  - MySQL 5.1과 5.5 버전이라면, MyISAM이나 MEMORY 스토리지 엔진에 성능상 장점이 있겠지만 8.0버전에서는 더 이상 무의미하다.

    

- MEMORY 스토리지 엔진이 'MEMORY' 라는 이름 때문에 과대평가를 받는 경우가 있지만 MEMORY 스토리지 엔진 또한 동시 처리 성능에 있어서 InnoDB 스토리지 엔진을 따라갈 수 없다.

  

- MEMORY 스토리지 엔진은 모든 처리를 메모리에서만 수행하니 빠를 것이라고 예상할 수 있겠지만, 하나의 스레드에서만 데이터를 읽고 쓴다면 InnoDB보다 빠를 수 있다.

  - 하지만, MySQL 서버는 일반 적으로 온라인 트랜잭션 처리를 위한 목적으로 사용되며, 온라인 트랜잭션 처리에는 동시 처리 성능이 매우 중요하다.

    동시에 몇십 또는 몇백 개의 클라이언트에서 쿼리 요청이 실행되는 경우라면 MEMORY 스토리지 엔진은 테이블 수준의 잠금으로 인해 제대로 된 성능을 내지 못할 것이다.

    

- MySQL 서버는 사용자의 쿼리를 처리하기 위해 내부적으로 임시 테이블을 사용할 수도 있다. MySQL 5.7 버전까지만 해도 MEMORY 스토리지 엔진이 내부 임시 테이블의 용도로 사용되었다.

  - 하지만 MEMORY 스토리지 엔진은 가변 길이 타입의 컬럼을 지원하지 않는다는 문제점 때문에 8.0부터는 TempTable 스토리지 엔진이 MEMORY 스토리지 엔진을 대체해 사용되고 있다.
    - 8.0부터는 internal_tmp_mem_storage_engine 시스템 변수를 이용해 내부 임시 테이블을 위해 TempTable 엔진을 사용할지 MEMORY 엔진을 사용할지 선택할 수 있다. 하지만 굳이 MEMORY 스토리지 엔진을 선택해서 얻을 수 있는 장점이 없어졌으므로, 이전 버전과의 호환성 유지 차원일 뿐 향후 버전에서는 제거될 것응로 보인다.



<br>

***

### MyISAM 스토리지 엔진 아키텍처

![KakaoTalk_Photo_2021-12-18-13-31-36](https://user-images.githubusercontent.com/50399804/149064220-f6cfa586-59b2-4c47-b542-5fdb24e4d3ae.jpeg)

- __키 캐시__

  - InnoDB의 버퍼 풀과 비슷할 역할을 하는 것으로, 인덱스만을 대상으로 작동하며, 또한 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.

    

  - 키 캐시가 얼마나 효율적으로 작동하는지는 다음 수식으로 확인할 수 있다고 한다.

    - Hit Rate = 100 - ( Key_reads / Key_read_requests * 100 )

      

    - Key_reads는 인덱스를 디스크에서 읽어 들인 횟수를 저장하는 상태 변수이며, Key_read_requests는 키 캐시로부터 인덱스를 읽은 횟수를 저장하는 상태 변수이다.

      

  - 메뉴얼에서는 일반적으로 키 캐시를 이용한 쿼리의 비율(히트율)을 99% 이상으로 유지하라고 권장한다.

    - 99% 미만이라면 키 캐시를 조금 더 크게 설정하는 것이 좋다.

      

    - 32비트 운영체제에서는 하나의 키 캐시에 4GB 이상의 메모리 공간을 설정할 수 없으므로 64비트 운영체제에서는 OS_PER_PROCESS_LIMIT 값에 설정된 크기만큼의 메모리를 할당할 수 있다.

      

    - 제한 값 이상의 키 캐시를 할당하고 싶다면, 기본(Default) 키 캐시 이외에 별도의 명명된 키 캐시 공간을 설정해야 한다.

      - 기본 키 캐시 공간을 설정하는 파라미터는 key_buffer_size 다.

      ```mysql
      key_buffer_size = 4GB
      kbuf_board.key_buffer_size = 2GB
      kbuf_comment.key_buffer_size = 2GB
      
      -- 기본 키 캐시 4GB, kbuf_board, kbuf_comment 라는 이름의 키 캐시가 각각 2GB씩 생성된다.
      ```

      

  - 기본(Default) 키 캐시 이외의 명명된 키 캐시 영역은 아무런 설정을 하지 않으면 메모리 할당만 해두고 사용하지 않게 된다는 점에 주의해야 한다.

    - 즉, 기본이 아닌 명명된 추가 키 캐시는 어떤 인덱스를 캐시할지 MyISAM 스토리지 엔진에 알려줘야 한다.

    ```mysql
    > CACHE INDEX db1.board, db2.board IN kbuf_board;
    > CACHE INDEX db1.comment, db2.coment IN kbuf_comment;
    ```

    - 키 캐시에 대한 더 자세한 설명은 MySQL 메뉴얼의 'Multiple Key caches' 부분을 참고하자.



- __운영체제의 캐시 및 버퍼__

  - MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다.

    

  - 하지만 MyISAM 테이블의 데이터에 대해서는 디스크로부터의 I/O를 해결해 줄만한 어떠한 캐시나 버퍼링 기능도 MyISAM 스토리지 엔진은 가지고 있지 않다.

    - 그래서 MyISAM 테이블의 데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청될 수 밖에 없다.

      

    - 물론 대부분의 운영체제에는 디스크로부터 읽고 쓰는 파일에 대한 캐시나 버퍼링 메커니즘을 탑재하고 있기 때문에 MySQL 서버가 요청하는 디스크 읽기 작업을 위해 매번 디스크의 파일을 읽지는 않는다.

      

  - 운영체제의 캐시 기능은 InnoDB처럼 데이터의 특성을 알고 전문적으로 캐시나 버퍼링을 하지는 못하지만, 그래도 여전히 없는 것보다는 낫다.

    

  - 운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙이다. 전체 메모리가 8GB 인데 MySQL 이나 다른 애플리케이션에서 메모리를 모두 사용해 버린다면 운영체제가 캐시 용도로 사용할 수 있는 메모리 공간이 없어진다. 이런 경우 MyISAM 테이블의 데이터를 캐시하지 못하며, 결론적으로 MyISAM 테이블에 대한 쿼리 처리가 느려진다.

    - 데이터베이스에서 MyISAM 테이블을 주료 사용한다면 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모미를 비워둬야 이러한 문제를 방지할 수 있다.

      

  - MyISAM이 주로 사용되는 MySQL 에서는 일반적으로 키 캐시는 최대 물리 메모리의 40% 이상을 넘지 않게 설정하고, 나머지 메모리 공간은 운영체제가 자체적인 파일 시스템을 위한 캐시 공간을 마련할 수 있게 해주는 것이 좋다.

    

- __데이터 파일과 프라이머리 키(인덱스) 구조__

  - InnoDB 스토리지 엔진을 사용하는 테이블은 프라이머리 키에 의해서 클러스터링 되어 저장되는 반면, __MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙(Heap) 공간처럼 활용된다.__

    - 즉, MyISAM 테이블에 레코드는 프라이머리 키 값과 무관하게 INSERT 되는 순서대로 데이터 파일에 저장된다. 그리고 MyISAM 테이블에 저장되는 레코드는 모두 ROWID 라는 물리적인 주소값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다.

      

  - MyISAM 테이블에서 ROWID는 가변 길이와 고정 길이의 두 가지 방법으로 저장될 수 있다.

    - 자세한 내용은 책을 참조하자.