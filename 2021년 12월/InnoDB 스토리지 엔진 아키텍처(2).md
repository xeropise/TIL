### Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록

  - 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있음

    

  - 위와 같이 페이지가 일부만 기록되는 현상을 파셜 페이지(Partial-page) 혹은 톤 페이지(Torn-page) 라고 하는데, 이런 현상은 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있음

    

- 위와 같은 문제를 막기 위해 Double-Write 기법을 이용한다.

  

  ![double_write_buffer_1](https://user-images.githubusercontent.com/50399804/148304632-e3449cbf-f229-465b-983d-ef79988cb3f0.png)

- A~D 까지의 더티 페이지를 디스크로 플러시한다고 가정한다면, 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록한다. 그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.

  

- 시스템 테이블스페이스의 DoubleWrite 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 더티 페이지가 정상적으로 기록되면 더이상 필요가 없어진다. 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.

  

- 페이지가 기록되는 도중 비정상 종료된다면, 엔진이 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다.

  - 관련 기능을 사용할지 여부는 [innodb_doublewrite 시스템변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite) 로 제어할 수 있다.

    

  - 데이터의 안전성을 위해 DoubleWrite 버퍼는 자주 사용되는데, HDD처럼 자기 원판이 회전하는 저장 시스템에서는 어차피 한 번의 순차 디스크 쓰기를 하는것이기 때문에 별로 부담이 되지 않지만 SSD처럼 랜덤 IO나 순차 IO의 비용이 비슷한 저장 시스템에서는 상당히 부담스럽다.

    

  - __데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite의 활성화를 고려하는 것이 좋다.__

    

  - 만약 데이터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정(innodb_flush_log_at_trx_commit 시스템 변수)을 1이 아닌 값으로 설정했다면 DoubleWrite도 비활성화하는 것이 좋다.



<br>

***

### 언두 로그

- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다.

  

- __이렇게 백업된 데이터를 언두 로그(Undo Log)라고 한다.__

  - 트랜잭션 보장

    - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.

      

  - 격리 수준 보장

    - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고, 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.

      

- 매우 중요한 역할을 담당하지만 관리 비용도 많이 필요하므로 어떤 문제점을 가지고 있고, 이를 위해 어떤 기능이 있는지 살펴 보자.



- __언두 로그 레코드 모니터링__

  - 언두 로그의 데이터는 위에서 말했듯 크게 2가지 용도로 사용된다.

    

  - MySQL 5.5 이전 버전의 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않아, 1억 건의 레코드가 저장된 100GB 크기의 테이블을 삭제한다고 가정하면 테이블의 크기만큼 공간 사용량이 늘어나 언두 로그 공간이 100GB이 되었다.

    

  - 대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때는 언두 로그의 양은 급격히 증가할 수 있다.

    

  - 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다.

    - 트랜잭션 관리가 잘못된 경우, 트랜잭션 실행 순서에 의해 디스크의 언두 로그 저장 공간이 계속 증가할 수도 있다.

      

    - 누적된 언두 로그로 인해, 디스크의 사용량이 증가하는 것은 그다지 큰 문제가 아닐 수도 있지만 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있으므로 쿼리의 성능이 전반적으로 떨어지게 된다.

      

  - 다행스럽게도 5.7과 8.0 에서는 언두 로그 공간의 문제점은 완전히 해결되어, 언두 로그를 돌아가면서 순차적으로 상요해 디스크 공간을 줄이는 것도 가능하며, 때로는 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여 주기도 한다.

  

  - 하지만 여전히 서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않으므로, __MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링하는 것이 좋다.__ 

    

  ```mysql
  -- MySQL 서버의 모든 버전에서 사용 가능한 명령
  > SHOW ENGINE INNODB STATUS
  
  ....
  HISTORY list length 31
  ....
  
  
  -- MySQL 8.0 버전에서 사용 가능한 명령
  > SELECT count
  	FROM information_schema.innodb_metrics
  	WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
  
  ```
  

  - MySQL 서버에서 실행되는 DML 문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그에 존재하는 레코드 건수는 상이할 수 있다.

    그래서 MySQL 서버별로 이 값은 차이를 보이므로, __서버별로 안정적인 시점의 언두 레코드 건수를 확인해 이를 기준으로 언두 로그의 급증여부를 모니터링하는 것이 좋다.__

    

- __언두 테이블스페이스 관리__

  - 언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)라고 한다.

    

  - 언두 테이블스페이스는 버전별로 많은 변화가 있었다.

    - 5.6 이전 버전에서는 언두 로그가 모두 시스템 테이블스페이스(ibdata.ibd)에 저장되었다. 하지만 테이블스페이스의 언두 로그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다.

      

    - 5.6 버전에서는 [innodb_undo_tablespaces 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces) 가 도입되었고, 2보다 큰 값으로 설정하면 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고, 별도의 언두 로그 파일을 사용했다.

      - 하지만 0으로 설정하면 여전히 이전 버전과 동일하게 언두 로그가 시스템 테이블스페이스에 저장되었다.

        

    - 8.0으로 업그레이드되면 (8.0.14~) innodb_undo_tablespaces 시스템 변수는 더 이상 효력이 없어졌으며(Deprecated), 언두 로그는 항상 시스템 테이블스페이스의 외부의 별도 로그 파일에 기록되도록 개선되었다.



![KakaoTalk_Photo_2021-12-07-09-07-17](https://user-images.githubusercontent.com/50399804/148307533-3fa18daa-409e-4c95-8d7a-4fe059adf397.jpeg)

> 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가진다.



- 하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나누 값의 개수만큼의 언두 슬롯을 가진다.

  - 페이지 크기가 16KB라면 하나의 롤백 세그먼트는 1024개의 언두 슬롯을 갖게 된다.

    

  - 하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 DML 문장의 특성에 따라 최대 4개까지 언두 슬롯을 사용하게 된다.

    

  - 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로, 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다ㅏ.

    - 그래서 최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측해 볼 수 있다.

    ```
    최대 동시 트랜잭션 수 = (innoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
    ```

    - 기본 설정 (innodb_undo_tablespaces=2, innodb_rollback_segments=128) 을 사용한다고 가정하면 대략 2097152개 정도의 트랜잭션이 동시에 처리 가능해진다.

      - 물론 일반적인 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 기본값으로 해서 크게 문제될 건 없으므로 가능하면 기본값을 유지하자.

        

  - __언두 로그 공간이 남는 것은 크게 문제되지 않지만 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.__

    

  - 언두 로그 관련 시스템 변수를 변경해야 한다면, 적절히 필요한 동시 트랜잭션 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다.

    - 8.0 이전까지는 한 번 생성된 언두 로그는 변경이 허용되지 않고, 정적으로 사용되었다.

      

    - 8.0 버전부터는 CREATE UNDO TABELSPACE 나 DROP TABLESPACE 같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선됐다.

    ```mysql
    > SELECT TABLESPACE_NAME, FILE_NAME
      FROM INFORMATION_SCHEMA.FILES
      WHERE FILE_TYPE LIKE 'UNDO LOG';
      
    > CREATE UNDO TABLESPACE extra_undo_003 ADD DATAFILE '/data/undo_dir/undo003';
    
    -- 언두 테이블스페이스 비활성화
    > ALTER UNDO TABLESPACE extra_undo_003 SET INACTIVE;
    
    -- 비활성화된 테이블 스페이스 삭제
    > DROP UNDO TABLESPACE extra_undo_003;
    ```

    

  - 언두 테이블스페이스의 불필요한 공간을 잘라내는(Truncate) 방법은 자동과 수동 2가지 방법이 있는데 모두 8.0 버전에서 지원된다. 자세한 것은 책을 참조하자.

    - [innodb_undo_log_truncate 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_log_truncate)



<br>

***

### [체인지 버퍼](https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html)

- __RDBMS 에서 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.__

  - 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다.

    

  - InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고, 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 된다.

    - __이때 사용하는 임시 메모리 공간을 체인지 버퍼(Change Buffer)라고 한다.__

    

- 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.

  

- 체인지 버퍼에 의해 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드(Merge thread) 라고 한다.

  - 5.5 버전 이전에서는 INSERT 만 가능했으나 5.5 버전 이후 부터 개선되면서 8.0 에서는 INSERT, DELETE, UPDATE 로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선되었다.

    

  - [innodb_change_buffering](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering) 이라는 시스템 변수가 새로 도입되어 작업의 종류별로 체인지 버퍼를 활성화할 수 있으며, 체인지 버퍼가 비효율적일 때는 체인지 버퍼를 사용하지 않게 설정할 수 있게 개선되었다.

    - all: 모든 인덱스 관련 작업(inserts + deletes + purges)을 버퍼링

    - none: 버퍼링 안함

    - inserts: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링

    - deletes: 인덱스에서  기존 아이템을 삭제하는 작업(삭제되었다는 마킹 작업)만 버퍼링

    - changes: 인덱스에 추가하고 삭제하는 작업만(inserts + deletes) 버퍼링

    - purges: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)

      

- 체인지 버퍼는 기본적으로 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정되어 있으며, 필요하다면 버퍼 풀의 50% 까지 사용하게 설정할 수 있다.

  - 체인지 버퍼가 너무 많은 버퍼 풀 공간을 사용하지 못하도록 한다거나 INSERT나 UPDATE 등이 너무 빈번하게 실행되어 체인지 버퍼가 더 많은 버퍼 풀을 사용할 수 있게 하고자 한다면 [innodb_change_buffer_max_size 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) 에 비율을 설정하면 된다.

  

- 체인지 버퍼가 버퍼 풀의 메모리를 얼마나 사용 중인지, 얼마나 많은 변경 사항을 버퍼링하고 있는지는 다음과 같이 확인할 수 있다.

```mysql
-- 체인지 버퍼가 사용 중인 메모리 공간의 크기
> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
  FROM performance_schema.memory_summary_global_by_event_name
  WHERE EVENT_NAME='memory/innodb/ibuf0ibuf';
  
  
-- 체인지 버퍼 관련 오퍼레이션 처리 횟수
> SHOW ENGINE INNODB STATUS

....
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
-- 관련 내용
...
```



<br>

***

### 리두 로그 및 로그 버퍼

- 리두 로그(Redo Log)는 트랜잭션의 4가지 요소이 ACID 중에서 D(Durable)에 해당하는 영속성과 가장 밀접하게 연관되어 있다.

  

- __리두 로그는 하드웨어나 소프으웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다.__

  

- MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 거의 모든 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기 때문에 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하다.

  - 그래서 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 필요하다.

    

  - 이로 인한 성능 저하를 막기 위해 데이터베이스 서버는 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있으며, 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다.

    

- 데이터베이스 서버는 ACID도 중요하지만 성능도 중요하기 때문에 데이터 파일뿐만 아니라 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀이나 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다.

  

- MySQL 서버가 비정상 종료되는 경우, InnoDB 스토리지 엔진의 데이터 파일은 다음과 같은 2가지 종류의 일관되지 않은 데이터를 가질 수 있다.

  - 커밋되었지만, 데이터 파일에 기록되지 않은 데이터

    - 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하기만 하면 된다.

    

  - 롤백되었지만, 데이터 파일에 이미 기록된 데이터

    - 리두 로그로는 해결할 수 없어, 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다.

      

    - 그렇다고 리두 로그가 전혀 필요하지 않은 것은 아니라, 최소한 그 변경이 커밋되었는지, 롤백되었는지, 아니면 트랜잭션의 실행 중간 상태였는지를 확인하기 위해서라도 리두 로그가 필요하다.

      

- 데이터베이스 서버에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.

  - 당연히 그렇게 되어야만 서버가 비정상적으로 종료되었을 때 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있고, 그 리두 로그를 이용해 장애 직전 시점까지의 복구가 가능해진다.

    

  - 하지만 트랜잭션이 커밋될 때마다 리두 로그를 디스크에 기록하는 작업은 많은 부하를 유발한다.

    - 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 [innodb_flush_log_at_trx_commit 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit) 를 제공한다. 관련 자세한 내용은 책을 참조하자.

      

- InnoDB 스토리지 엔진의 리두 로그 파일들의 전체 크기는 스토리지 엔진이 가지고 있는 버퍼 풀의 효율성을 결정하기 때문에 신중히 결정해야 한다.

  - 리두 로그 파일의 크기는 innodb_log_file_size, 리두 로그 파일의 개수는 innodb_log_files_in_group 시스템 변수로 결정할 수 있다.

    - 전체 리두 로그 파일의 크기는 두 시스템 변수의 곱으로 결정된다.

      

- 리두 로그 파일의 전체 크기가 InnoDB 버퍼 풀의 크기에 맞게 적절히 선택되어야 InnoDB 스토리지 엔진이 적절히 변경된 내용을 버퍼 풀에 모았다가 한 번에 모아서 디스크에 기록할 수 있다. 하지만 사용량(변경 작업)이 매우 많은 DBMS 서버의 경우 리두 로그의 기록 작업이 큰 문제가 되는데, 이러한 부분을 보완하기 위해 최대한 ACID 속성을 보장하는 수준에서 버퍼링한다. 

  - __이러한 리두 로그 버퍼링에서 사용되는 공간이 로그 버퍼다.__

  

- 로그 버퍼의 크기는 기본값인 16MB 수준에서 설정하는 것이 적합한데, BLOB이나 TEXT와 같이 큰 데이터를 자주 변경하는 경우에는 더 크게 설정하는 것이 좋다.



### 리두 로그 활성화 및 비활성화

- InnoDB 스토리지 엔진의 리두 로그는 하드웨어나 소프트웨어 등 여러 가지 문제점으로 MySQL 서버가 비정상적으로 종료되었을 때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화되어 있다.

  

- MySQL 서버에서 트랜잭션이 커밋되어도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그(트랜잭션 로그)는 항상 디스크로 기록된다.

  - innodb_flush_log_at_trx_commit 시스템 설정에 따라 즉시 동기화되지 않을 수도 있다.(0, 2일 경우)

    

- MySQL 8.0 이전 버전까지는 수동으로 리두 로그를 비활성화할 수 있는 방법이 없었지만, 8.0 버전부터는 수동으로 리두 로그를 활성화하거나 비활성화할 수 있게 되었다.

  

- 8.0 버전부터는 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우, 다음과 같이 리두 로그를 비활서오하해서 데이터의 적재 시간을 단축시킬 수 있다.

```mysql
> ALTER INSTANCE DISABLE INNODB REDO_LOG:

-- 리두 로그를 비활성화한 후 대량 데이터 적재를 실행
> LOAD DATA ...

> ALTER INSTANCE ENABLE INNODB REDO_LOG;


> SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';
```



- 리두 로그를 비활성화하고 데이터 적재 작업을 실행했다면 데이터 적재 완료 후 리두 로그를 다시 활성화하는 것을 잊지 말자.

  - 서버가 비정상적으로 종료된다면 MySQL 서버의 마지막 체크포인트 이후 시점의 데이터는 모두 복구할 수 없게 된다.

    

  - 더 심각한 문제는 서버의 데이터가 마지막 체크포인트 시점의 일관된 상태가 아닐 수 있다는 것이다. 

    (데이터 파일의 각 부분들이 다양한 시점의 데이터를 골고루 갖고 있을 수 있다.)

    

- MySQL 서버는 항상 새롭게 시작될 때 자신이 가진 리두 로그에서 데이터 파일에 기록되지 못한 데이터가 있는지 검사를 하게 되는데, 리두 로그가 비활성화된 상태에서 서버가 비정상적으로 종료되면 리두 로그를 이용한 복구가 불가능하므로 정상적으로 MySQL 서버가 시작되지 못할 수도 있다.

  - 이런 경우 innodb_force_recovery 시스템 변수를 6으로 설정하여 다시 시작해야 한다.

    

- 데이터가 중요하지 않더라도 서비스 도중에는 리두 로그를 활성화해서 MySQL 서버가 비정상적으로 종료되어도 특정 시점의 일관된 데이터를 가질 수 있게 하자. 

  - 만약 MySQL 서버가 비정상 종료되어 데이터가 일부 손실되어도  괜찮다면 리두 로그를 비활성화하는 것보다 innodb_flush_log_at_trx_commit 시스템 변수를 1이 아닌 0또는 2로 설정해서 사용할 것을 권장한다.



<br>

***

### [어댑티브 해시 인덱스](https://dev.mysql.com/doc/refman/8.0/en/innodb-adaptive-hash.html)

![다운로드](https://user-images.githubusercontent.com/50399804/148480432-95aed621-34e7-40bf-b3cf-ddd28fb3f397.png)

- 일반적으로 인덱스라고 하면 이는 테이블에 사용자가 생성해둔 B-Tree  인덱스를 의미한다.

  - 인덱스가 사용하는 알고리즘이 B-Tree는 아니더라도, 사용자가 직접 테이블에 생성해둔 인덱스가 우리가 일반적으로 알고 있는 인덱스일 것이다.

    

- __어댑티브 해시 인덱스(Adaptive Hash Index)는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스__ 를 말한다.

  - 즉 전체 데이터를 대상으로 해시값을 생성하지는 않고, Adaptive Hash Index에 할당되는 메모리는 전체 InnodB_Buffer_Pool_size의 1/64 만큼 초기화된다.

  

- [innodb_adaptive_hash_index 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index) 를 이용해서 어댑티브 해시 인덱스 기능을 활성화하거나 비활성화할 수 있다.

  

- B-Tree 인덱스에서 특정 값을 찾는 과정은 매우 빠르게 처리된다고 많은 사람이 생각하지만, 그 기준은 상대적인 것으로 데이터베이스 서버가 얼마나 많은 일을 하느냐에 따라 값을 찾는 과정이 느려질 수도 있고 빨라질 수도 있다.

  

- B-Tree 인덱스에서 특정 값을 찾기 위해서는 B-Tree의 루트 노드를 거쳐서 브런치 노드, 그리고 최종적으로 리프 노드까지 찾아가야 원하는 레코드를 읽을 수 있다. 적당한 사양의 컴퓨터에서 이런 작업을 동시에 몇 개 실행한다고 해서 성능저하가 보이지는 않지만 몇천개의 스레드로 실행하면 컴퓨터는 CPU는 엄청난 프로세스 스케쥴링을 하게 되고 자연히 쿼리의 성능은 떨어진다.

  

- __어댑티브 해시 인덱스는 이러한 B-Tree의 검색 시간을 줄여주기 위해 도입된 기능이다.__ InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.

  - B-Tree를 루트노드부터 리프노드까지 찾아가는 비용이 없어지고, 그만큼 CPU는 적은 일을 하지만 쿼리의 성능은 빨라진다.

    

  - 그와 동시에 컴퓨터는 더 많은 쿼리를 동시에 처리할 수 있게 된다.

  

- 해시 인덱스는 '인덱스 키 값'과 해당 인덱스 키 값이 저장된 '데이터 페이지의 주소'의 쌍으로 관리되는데, 인덱스 키 값은 B-Tree 인덱스의 고유번호(Id)와 B-Tree 인덱스의 실제 키 값 조합으로 생성된다.

  

- __어댑티브 해시 인덱스의 키 값에 B-Tree 인덱스의 고유번호가 포함되는 이유는 InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재(물론 파티션이 되는 기능이 있지만)하기 때문이다.__ 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되며, 특정 키 값이 어느 인덱스에 속한 것인지도 구분해야 하기 때문이다.

  

- 데이터 페이지 주소는 실제 키 값이 저장된 데이터 페이지의 메모리 주소를 가지는데, 이는 InnoDB 버퍼 풀에 로딩된 페이지의 주소를 의미한다. 그래서 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리되고, 버퍼 풀에서 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다.

  

- 어댑티브 해시 인덱스가 보여줄 수 있는 성능 효과는 [카카오 테크에 관련 글](https://tech.kakao.com/2016/04/07/innodb-adaptive-hash-index/) 및 책에 자세한 내용이 언급되어 있으니 찾아보도록 하자.

  

- 여기까지만 보면 어댑티브 해시 인덱스가 팔방미인처럼 보이지만, 실제 어댑티브 해시 인덱스를 의도적으로 비활성화하는 경우도 많다. 어댑티브 해시 인덱스가 성능 향상에 크게 도움이 되지 않는 경우는 다음과 같다.

  - 디스크 읽기가 많은 경우

    

  - 특정 패턴의 쿼리가 많은 경우 (조인이나 LIKE 패턴 검색)

    

  - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

    

- 다음과 같은 경우에는 성능 향상에 많은 도움이 된다.

  - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 많지 않은 경우)

    

  - 동등 조건 검색 (동등 비교와 IN 연산자)이 많은 경우

    

  - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

    

- __단순히 어댑티브 해시 인덱스가 도움이 될지 아닐지를 판단하기는 쉽지 않은데, 한가지 확실한 것은 데이터 페이지를 메모리(버퍼 풀) 내에서 접근하는 것을 더 빠르게 만드는 기능이기 떄문에 데이터 페이지를 디스크에서 읽어오는 경우가 빈번한 데이터베이스 서버에서는 아무런 도움이 되지 않는다는 점이다.__

  

- 하나 더 기억해야 할 것은 어댑티브 해시 인덱스는 공짜 점심이 아니라 저장 공간인 메모리를 사용하며, 때로는 상당히 큰 메모리 공간을 사용할 수도 있으므로 어댑티브 해시 인덱스 또한 데이터 페이지의 인덱스 키가 해시 인덱스로 만들어져야 하고 불필요한 경우 제거되어야 하며, 어댑티브 해시 인덱스가 활성화되면 InnoDB 스토리지 엔진은 그 키 값이 해시 인덱스에 있든 없든 검색해봐야 한다는 것이다.

  - 즉, 해시 인덱스의 효율이 없는 경우에도 InnoDB는 계속 해시 인덱스를 사용할 것이다.

    

- 어댑티브 해시 인덱스는 테이블의 삭제 작업에도 많은 영향을 미치는데 테이블의 인덱스가 어댑티브 해시 인덱스에 적재되어 있다고 가정하고 테이블을 삭제하거나 변경하면, InnoDB 스토리지 엔진은 이 테이블이 가진 모든 데이터 페에지의 내용을 어댑티브 해시 인덱스에서 제거해야 한다.

  - 이로 인해 테이블이 삭제되거나 스키마가 변경되는 동안 상당히 많은 CPU 자원을 사용하고, 그만큼 데이터베이스 서버의 처리 성능이 느려진다.

    

- __어댑티브 해시 인덱스의 도움을 많이 받을수록 테이블 삭제 또는 변경 작업은 더 치명적인 작업이 되는 것이므로 이는 어댑티브 해시 인덱스의 사용에 있어 매우 중요한 부분이므로 꼭 기억하자.__

  

- 어댑티브 해시 인덱스가 우리 서비스 패턴에 맞게 도움이 되는지 아니면 불필요한 오버헤드만 만들고 있는지를 판단해야 하는데, 정확한 판단을 할 수 있는 가장 쉬운 방법은 MySQL 서버의 상태 값들을 살펴 보는 것이다.

  - MySQL 서버에서 어댑티브 해시 인덱스는 기본적으로 활성화되어 있기 때문에 특별히 서버 설정을 변경하지 않았다면 이미 어댑티브 해시 인덱스를 사용 중인 상태이며, 아래 상태 값들이 유효한 통계를 가지고 있을 것이다.

    

    ```MYSQL
    > SHOW ENGINE INNODB STATUS
    
    ...
    
    -------------------------------------
    INSERT BUFFER AND ADAPTIVE HASH INDEX
    -------------------------------------
    ...
    Hash table size 8747, node heap has 1 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    Hash table size 8747, node heap has 0 buffer(s)
    1.03 hash searches/s, 2.64 non-hash searches/s
    
    ...
    ```

  -  위의 결과를 보면, 초당 3.67(=2.64 + 1.03)번의 검색이 실행됐는데, 그중 1.03 번은 어댑티브 해시 인덱스를 사용했고, 2.64 번은 해시 인덱스를 사용하지 못했다는 것을 알 수 있다.

    

  - 여기서 searches는 쿼리의 실행 횟수를 의미 하는 것이 아니라 쿼리가 처리되기 위해 내부적으로 키 값의 검색이 몇 번 실행됐느냐를 의미한다.

    

  - 어댑티브 해시 인덱스의 효율은 검색 횟수가 아니라 두 값의 비율 (해시 인덱스 히트율)과 어댑티브 해시 인덱스가 사용 중인 메모리 공간, 서버의 CPU 사용량을 종합해서 판단해야 한다.

    - 위의 경우 28% 정도가 어탭티브 해시 인덱스를 이용했다는 것을 알 수 있는데 서버의 CPU 사용량이 100%에 근접하다면 어댑티브 해시 인덱스는 효율적이라고 볼 수 있다.

    

  - 그런데 CPU의 사용량이 높지 않은데 28% 정도의 히트율이라면 어댑티브 해시 인덱스를 비활성화하는 편이 더 나을 수도 있다

    .

  - 이 경우에는 어댑티브 해시 인덱스가 사용 중인 메모리 사용량이 높다면, 어댑티브 해시 인덱스를 비활성화해서 InnoDB 버퍼 풀이 더 많은 메모리를 사용할 수 있게 유도하는 것도 좋은 방법이다.

    

  - 어댑티브 해시 인덱스의 메모리 사용량은 다음과 같이 performance_schema 를 이용해서 확인 가능하다.

    ```mysql
    > SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
      FROM performance_schema.memoery_summary_global_by_event_name
      WHERE EVENt_NAME='memory/innodb/adaptive hash index';
    ```

    

    

    
