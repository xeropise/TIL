### Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록

  - 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있음

    

  - 위와 같이 페이지가 일부만 기록되는 현상을 파셜 페이지(Partial-page) 혹은 톤 페이지(Torn-page) 라고 하는데, 이런 현상은 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있음

    

- 위와 같은 문제를 막기 위해 Double-Write 기법을 이용한다.

  

  ![double_write_buffer_1](https://user-images.githubusercontent.com/50399804/148304632-e3449cbf-f229-465b-983d-ef79988cb3f0.png)

- A~D 까지의 더티 페이지를 디스크로 플러시한다고 가정한다면, 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록한다. 그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.

  

- 시스템 테이블스페이스의 DoubleWrite 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 더티 페이지가 정상적으로 기록되면 더이상 필요가 없어진다. 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.

  

- 페이지가 기록되는 도중 비정상 종료된다면, 엔진이 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다.

  - 관련 기능을 사용할지 여부는 [innodb_doublewrite 시스템변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite) 로 제어할 수 있다.

    

  - 데이터의 안전성을 위해 DoubleWrite 버퍼는 자주 사용되는데, HDD처럼 자기 원판이 회전하는 저장 시스템에서는 어차피 한 번의 순차 디스크 쓰기를 하는것이기 때문에 별로 부담이 되지 않지만 SSD처럼 랜덤 IO나 순차 IO의 비용이 비슷한 저장 시스템에서는 상당히 부담스럽다.

    

  - __데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite의 활성화를 고려하는 것이 좋다.__

    

  - 만약 데이터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정(innodb_flush_log_at_trx_commit 시스템 변수)을 1이 아닌 값으로 설정했다면 DoubleWrite도 비활성화하는 것이 좋다.



<br>

***

### 언두 로그

- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다.

  

- __이렇게 백업된 데이터를 언두 로그(Undo Log)라고 한다.__

  - 트랜잭션 보장

    - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.

      

  - 격리 수준 보장

    - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고, 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.

      

- 매우 중요한 역할을 담당하지만 관리 비용도 많이 필요하므로 어떤 문제점을 가지고 있고, 이를 위해 어떤 기능이 있는지 살펴 보자.



- __언두 로그 레코드 모니터링__

  - 언두 로그의 데이터는 위에서 말했듯 크게 2가지 용도로 사용된다.

    

  - MySQL 5.5 이전 버전의 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않아, 1억 건의 레코드가 저장된 100GB 크기의 테이블을 삭제한다고 가정하면 테이블의 크기만큼 공간 사용량이 늘어나 언두 로그 공간이 100GB이 되었다.

    

  - 대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때는 언두 로그의 양은 급격히 증가할 수 있다.

    

  - 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다.

    - 트랜잭션 관리가 잘못된 경우, 트랜잭션 실행 순서에 의해 디스크의 언두 로그 저장 공간이 계속 증가할 수도 있다.

      

    - 누적된 언두 로그로 인해, 디스크의 사용량이 증가하는 것은 그다지 큰 문제가 아닐 수도 있지만 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있으므로 쿼리의 성능이 전반적으로 떨어지게 된다.

      

  - 다행스럽게도 5.7과 8.0 에서는 언두 로그 공간의 문제점은 완전히 해결되어, 언두 로그를 돌아가면서 순차적으로 상요해 디스크 공간을 줄이는 것도 가능하며, 때로는 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여 주기도 한다.

  

  - 하지만 여전히 서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않으므로, __MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링하는 것이 좋다.__ 

    

  ```mysql
  -- MySQL 서버의 모든 버전에서 사용 가능한 명령
  > SHOW ENGINE INNODB STATUS
  
  ....
  HISTORY list length 31
  ....
  
  
  -- MySQL 8.0 버전에서 사용 가능한 명령
  > SELECT count
  	FROM information_schema.innodb_metrics
  	WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
  
  ```
  

  - MySQL 서버에서 실행되는 DML 문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그에 존재하는 레코드 건수는 상이할 수 있다.

    그래서 MySQL 서버별로 이 값은 차이를 보이므로, __서버별로 안정적인 시점의 언두 레코드 건수를 확인해 이를 기준으로 언두 로그의 급증여부를 모니터링하는 것이 좋다.__

    

- __언두 테이블스페이스 관리__

  - 언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)라고 한다.

    

  - 언두 테이블스페이스는 버전별로 많은 변화가 있었다.

    - 5.6 이전 버전에서는 언두 로그가 모두 시스템 테이블스페이스(ibdata.ibd)에 저장되었다. 하지만 테이블스페이스의 언두 로그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다.

      

    - 5.6 버전에서는 [innodb_undo_tablespaces 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces) 가 도입되었고, 2보다 큰 값으로 설정하면 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고, 별도의 언두 로그 파일을 사용했다.

      - 하지만 0으로 설정하면 여전히 이전 버전과 동일하게 언두 로그가 시스템 테이블스페이스에 저장되었다.

        

    - 8.0으로 업그레이드되면 (8.0.14~) innodb_undo_tablespaces 시스템 변수는 더 이상 효력이 없어졌으며(Deprecated), 언두 로그는 항상 시스템 테이블스페이스의 외부의 별도 로그 파일에 기록되도록 개선되었다.



![KakaoTalk_Photo_2021-12-07-09-07-17](https://user-images.githubusercontent.com/50399804/148307533-3fa18daa-409e-4c95-8d7a-4fe059adf397.jpeg)

> 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가진다.



- 하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나누 값의 개수만큼의 언두 슬롯을 가진다.

  - 페이지 크기가 16KB라면 하나의 롤백 세그먼트는 1024개의 언두 슬롯을 갖게 된다.

    

  - 하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 DML 문장의 특성에 따라 최대 4개까지 언두 슬롯을 사용하게 된다.

    

  - 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로, 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다ㅏ.

    - 그래서 최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측해 볼 수 있다.

    ```
    최대 동시 트랜잭션 수 = (innoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
    ```

    - 기본 설정 (innodb_undo_tablespaces=2, innodb_rollback_segments=128) 을 사용한다고 가정하면 대략 2097152개 정도의 트랜잭션이 동시에 처리 가능해진다.

      - 물론 일반적인 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 기본값으로 해서 크게 문제될 건 없으므로 가능하면 기본값을 유지하자.

        

  - __언두 로그 공간이 남는 것은 크게 문제되지 않지만 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.__

    

  - 언두 로그 관련 시스템 변수를 변경해야 한다면, 적절히 필요한 동시 트랜잭션 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다.

    - 8.0 이전까지는 한 번 생성된 언두 로그는 변경이 허용되지 않고, 정적으로 사용되었다.

      

    - 8.0 버전부터는 CREATE UNDO TABELSPACE 나 DROP TABLESPACE 같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선됐다.

    ```mysql
    > SELECT TABLESPACE_NAME, FILE_NAME
      FROM INFORMATION_SCHEMA.FILES
      WHERE FILE_TYPE LIKE 'UNDO LOG';
      
    > CREATE UNDO TABLESPACE extra_undo_003 ADD DATAFILE '/data/undo_dir/undo003';
    
    -- 언두 테이블스페이스 비활성화
    > ALTER UNDO TABLESPACE extra_undo_003 SET INACTIVE;
    
    -- 비활성화된 테이블 스페이스 삭제
    > DROP UNDO TABLESPACE extra_undo_003;
    ```

    

  - 언두 테이블스페이스의 불필요한 공간을 잘라내는(Truncate) 방법은 자동과 수동 2가지 방법이 있는데 모두 8.0 버전에서 지원된다. 자세한 것은 책을 참조하자.

    - [innodb_undo_log_truncate 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_log_truncate)

