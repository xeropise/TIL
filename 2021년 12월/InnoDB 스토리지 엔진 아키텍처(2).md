### Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록

  - 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있음

    

  - 위와 같이 페이지가 일부만 기록되는 현상을 파셜 페이지(Partial-page) 혹은 톤 페이지(Torn-page) 라고 하는데, 이런 현상은 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있음

    

- 위와 같은 문제를 막기 위해 Double-Write 기법을 이용한다.

  

  ![double_write_buffer_1](https://user-images.githubusercontent.com/50399804/148304632-e3449cbf-f229-465b-983d-ef79988cb3f0.png)

- A~D 까지의 더티 페이지를 디스크로 플러시한다고 가정한다면, 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록한다. 그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.

  

- 시스템 테이블스페이스의 DoubleWrite 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 더티 페이지가 정상적으로 기록되면 더이상 필요가 없어진다. 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.

  

- 페이지가 기록되는 도중 비정상 종료된다면, 엔진이 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다.

  - 관련 기능을 사용할지 여부는 [innodb_doublewrite 시스템변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite) 로 제어할 수 있다.

    

  - 데이터의 안전성을 위해 DoubleWrite 버퍼는 자주 사용되는데, HDD처럼 자기 원판이 회전하는 저장 시스템에서는 어차피 한 번의 순차 디스크 쓰기를 하는것이기 때문에 별로 부담이 되지 않지만 SSD처럼 랜덤 IO나 순차 IO의 비용이 비슷한 저장 시스템에서는 상당히 부담스럽다.

    

  - __데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite의 활성화를 고려하는 것이 좋다.__

    

  - 만약 데이터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정(innodb_flush_log_at_trx_commit 시스템 변수)을 1이 아닌 값으로 설정했다면 DoubleWrite도 비활성화하는 것이 좋다.



<br>

***

### 언두 로그

- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다.

  

- __이렇게 백업된 데이터를 언두 로그(Undo Log)라고 한다.__

  - 트랜잭션 보장

    - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.

      

  - 격리 수준 보장

    - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고, 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.

      

- 매우 중요한 역할을 담당하지만 관리 비용도 많이 필요하므로 어떤 문제점을 가지고 있고, 이를 위해 어떤 기능이 있는지 살펴 보자.



- __언두 로그 레코드 모니터링__

  - 언두 로그의 데이터는 위에서 말했듯 크게 2가지 용도로 사용된다.

    

  - MySQL 5.5 이전 버전의 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않아, 1억 건의 레코드가 저장된 100GB 크기의 테이블을 삭제한다고 가정하면 테이블의 크기만큼 공간 사용량이 늘어나 언두 로그 공간이 100GB이 되었다.

    

  - 대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때는 언두 로그의 양은 급격히 증가할 수 있다.

    

  - 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다.

    - 트랜잭션 관리가 잘못된 경우, 트랜잭션 실행 순서에 의해 디스크의 언두 로그 저장 공간이 계속 증가할 수도 있다.

      

    - 누적된 언두 로그로 인해, 디스크의 사용량이 증가하는 것은 그다지 큰 문제가 아닐 수도 있지만 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있으므로 쿼리의 성능이 전반적으로 떨어지게 된다.

      

  - 다행스럽게도 5.7과 8.0 에서는 언두 로그 공간의 문제점은 완전히 해결되어, 언두 로그를 돌아가면서 순차적으로 상요해 디스크 공간을 줄이는 것도 가능하며, 때로는 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여 주기도 한다.

  

  - 하지만 여전히 서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않으므로, __MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링하는 것이 좋다.__ 

    

  ```mysql
  -- MySQL 서버의 모든 버전에서 사용 가능한 명령
  > SHOW ENGINE INNODB STATUS
  
  ....
  HISTORY list length 31
  ....
  
  
  -- MySQL 8.0 버전에서 사용 가능한 명령
  > SELECT count
  	FROM information_schema.innodb_metrics
  	WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
  
  ```
  

  - MySQL 서버에서 실행되는 DML 문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그에 존재하는 레코드 건수는 상이할 수 있다.

    그래서 MySQL 서버별로 이 값은 차이를 보이므로, __서버별로 안정적인 시점의 언두 레코드 건수를 확인해 이를 기준으로 언두 로그의 급증여부를 모니터링하는 것이 좋다.__

    

- __언두 테이블스페이스 관리__

  - 언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)라고 한다.

    

  - 언두 테이블스페이스는 버전별로 많은 변화가 있었다.

    - 5.6 이전 버전에서는 언두 로그가 모두 시스템 테이블스페이스(ibdata.ibd)에 저장되었다. 하지만 테이블스페이스의 언두 로그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다.

      

    - 5.6 버전에서는 [innodb_undo_tablespaces 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces) 가 도입되었고, 2보다 큰 값으로 설정하면 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고, 별도의 언두 로그 파일을 사용했다.

      - 하지만 0으로 설정하면 여전히 이전 버전과 동일하게 언두 로그가 시스템 테이블스페이스에 저장되었다.

        

    - 8.0으로 업그레이드되면 (8.0.14~) innodb_undo_tablespaces 시스템 변수는 더 이상 효력이 없어졌으며(Deprecated), 언두 로그는 항상 시스템 테이블스페이스의 외부의 별도 로그 파일에 기록되도록 개선되었다.



![KakaoTalk_Photo_2021-12-07-09-07-17](https://user-images.githubusercontent.com/50399804/148307533-3fa18daa-409e-4c95-8d7a-4fe059adf397.jpeg)

> 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가진다.



- 하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나누 값의 개수만큼의 언두 슬롯을 가진다.

  - 페이지 크기가 16KB라면 하나의 롤백 세그먼트는 1024개의 언두 슬롯을 갖게 된다.

    

  - 하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 DML 문장의 특성에 따라 최대 4개까지 언두 슬롯을 사용하게 된다.

    

  - 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로, 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다ㅏ.

    - 그래서 최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측해 볼 수 있다.

    ```
    최대 동시 트랜잭션 수 = (innoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
    ```

    - 기본 설정 (innodb_undo_tablespaces=2, innodb_rollback_segments=128) 을 사용한다고 가정하면 대략 2097152개 정도의 트랜잭션이 동시에 처리 가능해진다.

      - 물론 일반적인 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 기본값으로 해서 크게 문제될 건 없으므로 가능하면 기본값을 유지하자.

        

  - __언두 로그 공간이 남는 것은 크게 문제되지 않지만 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.__

    

  - 언두 로그 관련 시스템 변수를 변경해야 한다면, 적절히 필요한 동시 트랜잭션 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다.

    - 8.0 이전까지는 한 번 생성된 언두 로그는 변경이 허용되지 않고, 정적으로 사용되었다.

      

    - 8.0 버전부터는 CREATE UNDO TABELSPACE 나 DROP TABLESPACE 같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선됐다.

    ```mysql
    > SELECT TABLESPACE_NAME, FILE_NAME
      FROM INFORMATION_SCHEMA.FILES
      WHERE FILE_TYPE LIKE 'UNDO LOG';
      
    > CREATE UNDO TABLESPACE extra_undo_003 ADD DATAFILE '/data/undo_dir/undo003';
    
    -- 언두 테이블스페이스 비활성화
    > ALTER UNDO TABLESPACE extra_undo_003 SET INACTIVE;
    
    -- 비활성화된 테이블 스페이스 삭제
    > DROP UNDO TABLESPACE extra_undo_003;
    ```

    

  - 언두 테이블스페이스의 불필요한 공간을 잘라내는(Truncate) 방법은 자동과 수동 2가지 방법이 있는데 모두 8.0 버전에서 지원된다. 자세한 것은 책을 참조하자.

    - [innodb_undo_log_truncate 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_log_truncate)



<br>

***

### [체인지 버퍼](https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html)

- __RDBMS 에서 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.__

  - 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다.

    

  - InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고, 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 된다.

    - __이때 사용하는 임시 메모리 공간을 체인지 버퍼(Change Buffer)라고 한다.__

    

- 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.

  

- 체인지 버퍼에 의해 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드(Merge thread) 라고 한다.

  - 5.5 버전 이전에서는 INSERT 만 가능했으나 5.5 버전 이후 부터 개선되면서 8.0 에서는 INSERT, DELETE, UPDATE 로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선되었다.

    

  - [innodb_change_buffering](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering) 이라는 시스템 변수가 새로 도입되어 작업의 종류별로 체인지 버퍼를 활성화할 수 있으며, 체인지 버퍼가 비효율적일 때는 체인지 버퍼를 사용하지 않게 설정할 수 있게 개선되었다.

    - all: 모든 인덱스 관련 작업(inserts + deletes + purges)을 버퍼링

    - none: 버퍼링 안함

    - inserts: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링

    - deletes: 인덱스에서  기존 아이템을 삭제하는 작업(삭제되었다는 마킹 작업)만 버퍼링

    - changes: 인덱스에 추가하고 삭제하는 작업만(inserts + deletes) 버퍼링

    - purges: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)

      

- 체인지 버퍼는 기본적으로 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정되어 있으며, 필요하다면 버퍼 풀의 50% 까지 사용하게 설정할 수 있다.

  - 체인지 버퍼가 너무 많은 버퍼 풀 공간을 사용하지 못하도록 한다거나 INSERT나 UPDATE 등이 너무 빈번하게 실행되어 체인지 버퍼가 더 많은 버퍼 풀을 사용할 수 있게 하고자 한다면 [innodb_change_buffer_max_size 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) 에 비율을 설정하면 된다.

  

- 체인지 버퍼가 버퍼 풀의 메모리를 얼마나 사용 중인지, 얼마나 많은 변경 사항을 버퍼링하고 있는지는 다음과 같이 확인할 수 있다.

```mysql
-- 체인지 버퍼가 사용 중인 메모리 공간의 크기
> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
  FROM performance_schema.memory_summary_global_by_event_name
  WHERE EVENT_NAME='memory/innodb/ibuf0ibuf';
  
  
-- 체인지 버퍼 관련 오퍼레이션 처리 횟수
> SHOW ENGINE INNODB STATUS

....
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
-- 관련 내용
...
```



<br>

***

### 리두 로그 및 로그 버퍼

- 리두 로그(Redo Log)는 트랜잭션의 4가지 요소이 ACID 중에서 D(Durable)에 해당하는 영속성과 가장 밀접하게 연관되어 있다.

  

- __리두 로그는 하드웨어나 소프으웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다.__

  

- MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 거의 모든 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기 때문에 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하다.

  - 그래서 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 필요하다.

    

  - 이로 인한 성능 저하를 막기 위해 데이터베이스 서버는 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있으며, 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다.

    

- 데이터베이스 서버는 ACID도 중요하지만 성능도 중요하기 때문에 데이터 파일뿐만 아니라 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀이나 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다.

  

- MySQL 서버가 비정상 종료되는 경우, InnoDB 스토리지 엔진의 데이터 파일은 다음과 같은 2가지 종류의 일관되지 않은 데이터를 가질 수 있다.

  - 커밋되었지만, 데이터 파일에 기록되지 않은 데이터

    - 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하기만 하면 된다.

    

  - 롤백되었지만, 데이터 파일에 이미 기록된 데이터

    - 리두 로그로는 해결할 수 없어, 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다.

      

    - 그렇다고 리두 로그가 전혀 필요하지 않은 것은 아니라, 최소한 그 변경이 커밋되었는지, 롤백되었는지, 아니면 트랜잭션의 실행 중간 상태였는지를 확인하기 위해서라도 리두 로그가 필요하다.

      

- 데이터베이스 서버에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.

  - 당연히 그렇게 되어야만 서버가 비정상적으로 종료되었을 때 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있고, 그 리두 로그를 이용해 장애 직전 시점까지의 복구가 가능해진다.

    

  - 하지만 트랜잭션이 커밋될 때마다 리두 로그를 디스크에 기록하는 작업은 많은 부하를 유발한다.

    - 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 [innodb_flush_log_at_trx_commit 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit) 를 제공한다. 관련 자세한 내용은 책을 참조하자.

      

- InnoDB 스토리지 엔진의 리두 로그 파일들의 전체 크기는 스토리지 엔진이 가지고 있는 버퍼 풀의 효율성을 결정하기 때문에 신중히 결정해야 한다.

  - 리두 로그 파일의 크기는 innodb_log_file_size, 리두 로그 파일의 개수는 innodb_log_files_in_group 시스템 변수로 결정할 수 있다.

    - 전체 리두 로그 파일의 크기는 두 시스템 변수의 곱으로 결정된다.

      

- 리두 로그 파일의 전체 크기가 InnoDB 버퍼 풀의 크기에 맞게 적절히 선택되어야 InnoDB 스토리지 엔진이 적절히 변경된 내용을 버퍼 풀에 모았다가 한 번에 모아서 디스크에 기록할 수 있다. 하지만 사용량(변경 작업)이 매우 많은 DBMS 서버의 경우 리두 로그의 기록 작업이 큰 문제가 되는데, 이러한 부분을 보완하기 위해 최대한 ACID 속성을 보장하는 수준에서 버퍼링한다. 

  - __이러한 리두 로그 버퍼링에서 사용되는 공간이 로그 버퍼다.__

  

- 로그 버퍼의 크기는 기본값인 16MB 수준에서 설정하는 것이 적합한데, BLOB이나 TEXT와 같이 큰 데이터를 자주 변경하는 경우에는 더 크게 설정하는 것이 좋다.