### User, Kernel Area

![다운로드 (3)](https://user-images.githubusercontent.com/50399804/138989946-75c73c25-736e-4ff6-aaad-6d3366a1c776.png)

- 운영체제의 컴퓨터 메모리에는 2가지 공간이 있음

  - 유저(User) Area

    - 프로그램이 동작하기 위해 사용되는 메모리 공간 ( 코드, 데이터, 스택 및 힙 ) 을 가리키는 것을 말함. 

      - 데이터(Data)

        - 전역 변수와 static이 할당, 프로그램 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리에서 소멸 

          

      - 힙(Heap)

        - 필요에 의해 메모리를 동적으로 할당, 낮은 주소에서 높은 주소로 쌓임

          

        - 런타임에 크기가 결정된다.

        

      - 스택(Stack)

        - 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역

          

        - 쓰레드가 공유하는 영역, 높은 주소에서 낮은 주소로 쌓인다.

          

        - 컴파일 타임에 크기가 결정된다.

        

    - 응용 프로그램이 실행되는 기본모드, 물리적인 영역으로의 접근이 허용되지 않아 접근할 수 있는 메모리에도 제한이 있다.

    

  - 커널(Kernel) Area

    - 하나의 프로세스에 할당되는 총 메모리 공간 중 유저 영역을 제외한 나머지 영역, 시스템 운영에 필요한 메모리

    

    - 운영체제라는 하나의 소프트웨어를 실행시키기 위해 필요한 메모리 공간

      

    - 유저 영역에서 커널 영역으로의 접근은 불가능하며, 커널 모드로 전환이 필요하다.



- 메모리 공간을 분리하는 이유?
  - 일반 프로그램을 실행하기 위해 필요한 메모리 공간과 운영체제의 실행을 위한 메모리 공간을 분리시켜 놓지 않으면 메모리 관리가 힘들어짐



<br>

***

### User, Kernel Thread

- 쓰레드를 생성해 주는 대상이 유저 레벨인 경우 (User Thread)

  - 커널에서 쓰레드 기능을 지원하지 않아, 커널에 의존적이지 않은 형태로 쓰레드의 기능을 제공하는 라이브러리 활용

    

  - 이러한 방식으로 제공되는 쓰레드가 유저 레벨 쓰레드라고 함

    

  - 커널은 쓰레드의 존재를 모르므로 모드 간 전환이 필요 없음

    

  - 운영체제는 프로세스의 존재만 알고, 쓰레드의 존재를 모르므로 프로세스 내의 쓰레드 문제가 발생하지 않게 프로그래밍을 해야하기 떄문에 프로그래밍이 어렵고, 커널 레벨 쓰레드에 비해 결과 예측이 어렵다.

    

  - 하나의 쓰레드가 커널에 의해 블로킹 되면 프로세스 전체가 블로킹되고, 이를 해결하려면 프로그래밍이 어려워지고 커널 레벨 쓰레드에 비해 결과 예측이 어렵다.



- 쓰레드를 생성해 주는 대상이 커널 레벨인 경우 (Kernel Thread)

  - 프로그래머의 요청에 따라 쓰레드를 생성 및 스케쥴링하는 주체가 커널인 경우를 커널 레벨 쓰레드라고 한다.

  

  - 커널에서 직접 제공해 주기 때문에 안정성과 다양한 기능성이 제공됨

    

  - 멀티프로세서를 활용할 수 있다는 큰 장점이 있지만, 커널 모드에서는 쓰레드 단위로 스케쥴링이 안되므로, 각 CPU에 효율적으로 배당 불가

    

  - 커널에서 제공해주기 때문에 유저 모드에서 커널 모드로의 전환이 빈번하게 일어나 성능의 저하가 일어날 수 있다.

    

> https://velog.io/@recordsbeat/%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%8F%84%EB%8C%80%EC%B2%B4-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B8%B8%EB%9E%98
>
> https://awesome-dev.tistory.com/63?category=742265