```sql 
EXLPAIN tbl_name 

or

EXPLAIN [EXTENDED] SELECT select_options
```



- EXPLAIN 키워드를 사용함으로써, 내가 입력한 쿼리문이 어떻게 실행되었는지 확인이 가능하다.
  - 쿼리 실행 속도의 경우 EXPLAIN ANALYZE ~ 로 확인 가능하다. (MySQL 8.0 이상)




- EXTENDED 키워드가 사용되면,  EXPLAIN 명령문 다음에 SHOW WARNINGS 명령문을 입력해서 볼 수 있는 기타 정보를 리턴한다.

  - 옵티마이저가 SELECT 명령문에 있는 컬럼 이름과 테이블을 얼마나 많이 검증하였는지, 최적화 과정에 관한 어플리케이션 재 작성과 최적화 규칙, 다른 가능한 노트를 보여준다.

    

- EXPLAIN을 통해서 나오는 정보는 테이블에 대한 정보이므로 다음과 같은 정보를 가지고 있다.

![mysql-explain3](https://user-images.githubusercontent.com/50399804/145250617-606ad7a9-b322-44f4-a7ca-5edf646f5921.png)



- id

  - SELECT 식별자, 순차적인 번호

    

  - 실행 순서를 표시하는 숫자로, 조인할 때는 똑같은 ID가 표시가 된다.

    

  - 숫자가 작을 수록 먼저 수행된 것이므로, ID가 같은 값이라면 두 개 테이블의 조인이 이루어졌다고 해석할 수 있다.

    

  - ID가 같아 조인이 이뤄진 경우에서, 상위에 있는 경우 드라이빙 테이블, 하위에 있는 경우를 드리븐 테이블이라고 볼 수 있다.

    

  

- select_type

  - SELECT 문의 출력 유형을 나타낸다. 다음 종류 중 하나이다. (밑줄의 경우 쿼리 튜닝의 대상으로 고려해볼 수 있다.)

  | TYPE                      | DESCRIPTION                                                  |
  | ------------------------- | ------------------------------------------------------------ |
  | SIMPLE                    | UNION이나 내부 쿼리가 없는 SELECT 문, 단순한 SELECT 구문     |
  | PRIMARY                   | 서브쿼리가 포함된 SQL 문에서 첫 번째 SELECT 문에 해당하는 구문, UNION ALL 과 같은 쿼리의 경우 첫번째 실행되는 구문 |
  | UNION                     | 합쳐진 SELECT 문에서 첫 번째 SELECT 구문을 제외한 이후의 SELECT 구문 |
  | <u>DEPENDENT UNION</u>    | UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받은 경우, 첫 번째 단위 쿼리를 제외한 두 번째 제외 쿼리 |
  | UNION RESULT              | UNION 구문으로 SELECT 절을 결합했을 때 출력,                 |
  | SUBQUERY                  | 독립적으로 수행되는 서브쿼리                                 |
  | <u>DEPENDENT SUBQUERY</u> | UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받은 경우, 첫 번째 단위 쿼리 |
  | DERIVED                   | FROM 절에 작성된 서브쿼리(인라인 뷰)                         |
  | UNCACHEABLE SUBQUERY      | 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형, 사용자 정의 함수나 변수 혹은 함수를 사용하는 경우 |
  | MATERIALIZED              | IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형 |

  

- table

  - 행과 열이 참조하는 테이블, 테이블명을 표시하는 항목

    

  - 서브쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 <subquery#> 이나 <derived#> 으로 출력되는데 여기서 #에 표시된 숫자가 실행계획에서 ID를 나타낸다.

    -  <derived 2> 라면 ID가 2인 테이블이라는 뜻이다.


  

- type

  - 테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공하는 항목이다.

    

  - 풀테이블 스캔인지, 아니면 인덱스를 통해 바로 데이터를 찾아갈지 등을 해석가능하다.

    

    - system

      - 테이블의 데이터가 없거나 1개만 있는경우, 성능상 최상의 type

        

    - const

      - 조회되는 데이터가 단 1건일 때 출력되는 유형, 성능상 매우 유리한 방식

        

      - 하나의 열만이 존재하기 때문에, 이 열에 있는 컬럼에서 얻는 값은 옵티마이저에 의해 상수로 인식될 수 있다.

        

      - 한번 밖에 읽혀지지 않기 때문에 매우 빠르다.

        

      - PRIMARY KEY 또는 UNIQUE 인덱스의 모든 부분을 상수 값과 비교를 할 때 사용한다.

      ```sql
      SELECT * FROM tbl_name WHERE primary_key=1;
      
      SELECT * FROM tbl_name
      WHERE pirmary_key_part1=1 AND primary_key_part2=2;
      ```

      

    - eq_ref

      - 조인이 수행될 때 드리븐 테이블의 데이터에 접근하며 고유 인덱스 또는 기본 키로, 단 1건의 데이터를 조회하는 방식, 조인이 수행될 때 성능상 가장 유리한 경우로 성능상 가장 유리한 경우

        

    - ref

      - eq_ref와 유사한 유형이나 조인을 수행할 때 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미

        

      - 드라이빙 테이블과 드리븐 테이블이 조인을 수행하면 일대다 관계가 된다. 

        

      - 드리븐 테이블의 데이터양이 많지 않을 때는 성능 저하를 크게 우려하지 않아도 되지만, 데이터양이 많다면 접근해야 할 데이터 범위가 넓어져 성능 저하의 원인이 되는지 확인해야 한다.

        

        


    - ref_or_null

      - ref와 유사하지만, IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식

        

      - MySQL과 MariaDB는 NULL에 대해서도 인덱스를 활용하여 검색할 수 있으며, 이때 NULL은 가장 앞 쪽에 배치된다.

        

      - 검색할 NULL 데이터양이 많다면 SQL 튜닝의 대상이 된다.

        ```sql
        SELECT * FROM ref_Table
          WHERE key_column=expr OR key_column IS NULL;
        ```

      

    - fulltext

      - 텍스트 검색을 빠르게 처리하기 위해 전문 인덱스(full text index)를 사용하여 데이터에 접근하는 방식

      

    - index_merge

      - 결합된 인덱스들이 동시에 사용되는 유형, 특정 테이블에 생성된 2개 이상의 인덱스가 병합되어 동시에 적용된다. 이때 전문 인덱스는 제외

        

    - range

      - range 는 키 컬럼이 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN 또는 IN 연산자를 사용할 때 범위 스캔을 수행하는 방식

        

      - 스캔할 범위가 넓으면 성능 저하의 요인이 될 수 있으므로 SQL 튜닝 검토 대상이 된다.

      

    - Index

      - 인덱스 풀 스캔, 물리적인 인덱스 블록(block)을 처음부터 끝까지 훑는 방식

        

      - 데이터를 스캔하는 대상이 인덱스라는 점이 다를 뿐, 테이블 풀 스캔 방식과 유사하다.

        

      - 인덱스는 보통 테이블보다 크기가 작으므로 테이블 풀 스캔 방식보다 빠를 가능성이 높다. 하지만 검색 대상이 많다면 풀 테이블 스캔을 유도하자.

      

    - ALL

      - 테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 방식

        

      - 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는게 오히려 비효율적이라고 옵티마이저가 판단했을 때 선택

        

      - 인덱스를 새로 추가하거나 기존 인덱스를 변경하여 인덱스를 활용하는 방식으로 튜닝 가능하나, 전체 테이블의 10 ~ 20% 이상 분량의 데이터를 조회하는 경우에는 ALL 유형이 성능 상 유리할 수 있다.
      
        

  - possible_keys

    - 이 테이블에서 열을 찾기 위해 MySQL 이 선택가능한 인덱스를 표시한다.

      

    - 사용할 수 있는 후보군의 기본 키와 인덱스 목록만 보여주므로 SQL 튜닝의 효용성은 없다.

    

    - 테이블이 어떤 인덱스를 가지고 있는지 보기 위해서는 SHOW INDEX FROM tbl_name 을 사용한다.

      

  - key

    - key 컬럼은 MySQL 이 실제로 사용한 키(인덱스) 를 가리킨다.

      

    - 만일 아무런 인덱스도 선택되지 않았다면 NULL 이 된다.

      

    - MySQL로 하여금 possible_keys 컬럼에 있는 인덱스를 사용하거나 또는 무시하도록 만들기 위해, FORCE INDEX, USE INDEX 또는 IGNORE INDEX 를 쿼리에서 사용하도록 한다.

      

    - 비효율적인 인덱스를 사용했거나 인덱스 자체를 사용하지 않았다면 SQL 튜닝의 대상이 된다.

      

  - key_len

    - MySQL이 사용하기로 결정한 키의 길이(bytes)를 나타내는 컬럼으로, key 컬럼이 NULL 이라면 이 값도 NULL 이 된다.

      

    - 다중-부분(multiple-part) 키 중에 얼마나 많은 부분을 MySQL 이 실제로 사용하는지 알 수 있도록 해 준다.

      

  - ref

    - 테이블에서 열을 선택하기 위해 key 컬럼 안에 명명되어 있는 인덱스를 어떤 칼럼 또는 상수와 비교하는지를 보여준다.

    

  - rows

    - SQL 문을 수행하고자 접근하는 데이터의 모든 행(row) 수를 나타내는 예측 항목

      

    - 디스크에서 데이터 파일을 읽고 메모리에서 처리해야 할 행 수를 예상하는 값

      

    - MySQL이 통계 정보를 참고하여 산출하는 값이므로 수치가 정확하지 않다. 최종 출력될 행 수가 아니라는 점에 유의

      

    - SQL 문의 최종 결과 건수와 비교해 rows 수가 크게 차이 날 때는 불필요하게 MySQL 엔진까지 데이터를 많이 가져왔다는 뜻이므로 SQL 튜닝의 대상이 된다.

      

  - filtered

    - SQL 문을 통해 DB 엔진으로 가져온 데이터 대상으로 필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지 의미하는 항목

      

    - DB 엔진으로부터 100건의 데이터를 가져왔다면, WHERE 절의 조건으로 10건으로 필터링 되었을 경우, 10/100 = 10% 가 출력이 된다.(단위가 %)

      

    - 이것도 정확한 데이터는 아님에 유의하자.

    

  - Extra

    - SQL 문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목

      

    - 세미 콜론(;)으로 구분하여 여러 가지 정보를 나열할 수 있다.

      

      - Distinct

        - 중복이 제거되어 유일한 값을 찾을 때 출력되는 정보, distinct 키워드나 union 구문이 포함된 경우 출력

          

      - Using where

        - WHERE 절의 필터 조건을 사용해 MySQL 엔진으로 가져온 데이터를 추출할 것이라는 의미
      
        
      
    - Using temporary
      
        - 쿼리를 해석하기 위해, 결과를 저장할 임시 테이블을 하나 생성하겠다는 의미
      
        
      
      - 임시 테이블을 메모리에 생성하거나, 메모리 영역을 초과하여 디스크에 임시 테이블을 생성하면 성능 저하의 원인이 되므로 튜닝의 대상
      
      
      
    - Using filesort
      
      - 정렬이 필요한 데이터를 메모리에 올리고 정렬 작업을 수행한다는 의미
      
        
      
      - 인덱스를 사용하지 못해 정렬을 위해 메모리 영역에 데이터를 올리게 되는데, 추가적인 정렬 작업을 말한다.
      
        
      
      - SQL 튜닝의 대상이 된다.
      
        
      
    - Using join buffer
      
      - 조인을 수행하기 위해 중간 데이터 결과를 저장하는 조인 버퍼를 사용한다는 의미
      
        
      
      - 드라이빙 테이블의 데이터에 먼저 접근할 결과를 조인 버퍼에 담고 난 뒤, 조인 버퍼와 드리븐 테이블 간에 서로 일치하는 조인 키 값을 찾는 과정을 수행한다.
      
        
      
    - Using union / Using intersect / Using sort_union
      
      - 인덱스가 병합되어 실행되는 type 항목의 index_merge 유형에서 인덱스를 어떻게 병합했는지에 관한 상제 정보 
      
      
      
    - Using index
      
      - 물리적인 데이터 파일을 읽지 않고, 인덱스만을 읽어서 SQL 문의 요청사항을 처리할 수 있는 경우를 의미한다.
      
        
      
      - **커버링 인덱스로 처리됨 index only scan이라고도 부른다**
      
        
          
      - 인덱스로 구성된 열만 SQL 문에서 사용할 경우 이 방식을 활용한다.
      
      
      
    - Using index condition
      
      - Mysql 엔진에서 인덱스로 생성된 열의 필터 조건에 따라 요청된 데이터만 필터링하는 Using where 방식과 달리, 필터 조건을 스토리지 엔진으로 전달하여 필터링 작업에 대한 Mysql 엔진의 부하를 줄이는 방식
      
        
      
      - 스토리지 엔진의 데이터 결과를 Mysql 엔진으로 전송하는 데이터양을 줄여 성능 효율을 높일 수 있는 옵티마이저의 최적화 방식
      
        
      
      - 인덱스 컨디션 푸시다운(Index Condition PushDown) 옵션으로 5.6 버전 이상에서는 자동으로 제공한다고 한다.
      
        - 이하 일 경우, 옵션을 켜주도록 하자.
      
          
      
    - Using Index condition(BKA)
      
      - 데이터를 검색하기 위해 배치 키 액세스(BKA)를 사용하는 방식
      
        
      
    - Using index for group-by
      
      - 인덱스로 정렬 작업을 수행하는 인덱스 루스 스캔일 떄 출력되는 부가 정보
      

      

      - Not Exists
      - 하나의 일치하는 행을 찾으며 추가로 행을 더 검색하지 않아도 될 때 출력되는 유형



- 실행 계획을 수행하여 출력된 정보를 보았을 때, SQL 튜닝 대상인 실행 꼐획과 튜닝이 필요하지 않은 실행 계획을 구분하기는 너무 어려운 작업이다.

  

- 어느 쪽이 좋다 나쁘다고 말하기는 어렵지만, 다음과 같은 기준을 통해 참조 가능하다. (그렇다고 나쁜 쪽이 꼭 나쁜것은 아니다.. 중요한 것은 속도이다.)

  - select_type
    - 좋음
      - SIMPLE, PRIMARY, DERIVED
    - 나쁨
      - DEPEDENT *
      - UNCACHEABLE *
  - type
    - 좋음
      - system, const, eq_ref
    - 나쁨
      - index, all
  - extra
    - 좋음
      - Using index
    - 나쁨
      - Using filesort, Using temporary

