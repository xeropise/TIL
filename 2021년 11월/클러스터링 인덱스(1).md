## 클러스터링 인덱스

- 여러 개를 하나로 묶는다는 의미에서 클러스터링이 사용되는데, 인덱스의 클러스터링도 그 의미를 크게 벗어나지는 않는다.

  

- MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것 (PK기준) 들끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다.

  

- MySQL 에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않는다.



<br>

***

- 클러스터링 인덱스 테이블의 프라이머리 키 (PK)에 대해서만 적용되는 내용이다. 

  - 즉 PK 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 한다.

    ![9996ED405B78FDF435](https://user-images.githubusercontent.com/50399804/146004308-049e13de-4081-4ee1-a2f5-23b5b6e2941d.png)

    

- 여기서 중요한 것은, __PK 값에 의해 레코드의 저장 위치가 결정된다는 것이다.__

  - PK 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미한다.

    

  - PK 값으로 클러스터링된 테이블은 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 키를 결정해야 한다.

    

- 클러스터링 인덱스는 PK 값에 의해 레코드의 저장 위치가 결정되므로, 사실 인덱스의 알고리즘이라기보다는 테이블 레코드의 저장 방식이라고 볼 수 있다.

  

- '클러스터링 인덱스' 와 '클러스터링 테이블' 은 동의어로 사용되기도 한다.

  - 클러스터링 기준이 되는 PK는 '클러스터링 키' 라고도 표현한다.

    

- 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 PK 키 반의 검색이 매우 빠르며, 대신 레코드의 저장이나 PK의 변경이 상대적으로 느리다.

  

- 클러스터링 인덱스 구조를 보면, 구조 자체는 B-Tree와 비슷하지만, 보조 인덱스를 위한 B-Tree의 리프노드와는 달리 __클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있음을 알 수 있다.__

  

- 클러스터링 테이블에서 PK를 변경하는 문장이 실행되면 클러스터링 테이블의 데이터 레코드에는 어떤 변화가 일어날까?

  - 저장된 페이지가 변경된다.

    

  - 단, MyISAM 테이블이나 기타 InnoDB를 제외한 테이블의 데이터 레코드는 PK나 인덱스 키 값이 변경 된다고 해서 실제 데이터 레코드의 위치가 변경되지는 않는다.

    

- 그러면 PK가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성될까? PK가 없는 경우, InnoDB 스토리지 엔진이 다음 우선순위대로 PK를 대체할 컬럼을 선택한다.

  - PK가 있으면, 클러스터링 키로 선택

    

  - NOT NULL 옵션의 유니크 인덱스(UNIQUE_INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택

    

  - 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택

    

- InnoDB 스토리지 엔진이 적절한 클러스터링 키 후보를 찾지 못하는 경우, 스토리지 엔진이 내부적으로 레코드의 일련번호 컬럼을 생성한다.

  - 이렇게 자동으로 추가된 PK는 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없다.

    

  - 즉 PK나 유니크 인덱스가 전혀 없는 InnoDB 테이블에서는 아무 의미 없는 숫자 값으로 클러스터링 되는 것이며, 아무런 혜택을 주지 않는다.

    

  - 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하다면 PK를 명시적으로 생성하자.



<br>

***

### 세컨더리 인덱스에 미치는 영향

- MyISAM 이나 MEMORY 테이블 같은 클러스터링 되지 않은 테이블은 INSERT 될 때 처음 저장된 공간에서 절대 이동하지 않는다.

  

- 데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROW_ID) 역할을 한다.

  - 그리고 PK나 세컨더리 인덱스는 각 키의 레코드 아이디를 이용해 실제 데이터 레코드를 찾아온다.

  

- 그래서 MyISAM이나 MEMORY 테이블에서는 PK와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.

  

- InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 어떻게 될까?

  - 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고, 그때마다 해당 테이블의 모든 인덱스에 저장된 주소값을 변경해야 한다.

    

  - 이런 오버헤드를 제거하기 위해 __InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현되어 있다.__

  

<br>

***

### 클러스터링 인덱스의 장점과 단점

- 장점

  - PK는 검색할 때 처리 성능이 매우 빠르며, 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다. (커버링 인덱스)

    

- 단점

  - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값이 크기가 클 경우 전체적으로 인덱스 크기가 커짐

    

  - 세컨더리 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림

    

  - INSERT 할 때 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림

    

  - PK를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문이 처리 성능이 느림

    

- 일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing) 에서는 쓰기와 읽기의 비율이 2:8 또는 1:9 정도이기 때문에 조금 느린 쓰기를 감수하고, 읽기를 빠르게 유지하는 것이 매우 중요하다.

