## InnoDB 스토리지 엔진 아키텍처

![제목 없음](https://user-images.githubusercontent.com/50399804/146808621-374e7be5-40db-413b-8e38-3cd46e0841d1.png)



- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

  

- InnoDB 스토리지 엔진의 주요 특징들을 살펴 보자.

  

<br>

***

### PK에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다.

  - PK 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 PK의 값을 논리적인 주소로 사용한다.

    

- PK가 클러스터링 인덱스이므로 PK를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.

  

- 쿼리의 실행 계획에서 PK는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정 (다른 인덱스보다 선택될 확률이 높음)이 된다.

  

- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않아, 구조적으로 PK와 세컨더리 인덱스의 차이가 없다.

  - MyISAM에서는 PK는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.

    

  - MyISAM 테이블의 PK및 모든 인데스는 물리적인 레코드 주소 값(ROWID)을 가진다.



<br>

***

### 외래 키 지원

- 외래 키에 대한 지원은 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.

  

- 외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있는데, 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.

  

- InnoDB 에서 외래키는 부모 테이블과 자식테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 자금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다.

  

- 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수도 있다. 물론 부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제 없이 실행할 수 있지만, 외래 키가 복잡하게 얽힌 경우에는 그렇게 간단하지 않다.

  - 서비스에 문제가 있어 긴급하게 뭔가 조치를 해야하는데 이런 문제가 발생하면 더 조급해질 수도 있다.

    - __이런 경우, foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.__

      - 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠르게 처리할 수 있다.

      ```mysql
      > SET foreign_key_checks=OFF;
      ```

    

  - 외래 키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 간의 관계가 깨진 상태로 그대로 유지해도 된다는 것을 의미하지는 않는다.

    - __외래키 체크를 일시적으로 중지한 상태에서 외래 키 관계를 가진 부모 테이블의 레코드를 삭제했다면, 반드시 자식 테이블의 레코드도 삭제해서 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화해야 한다.__

      

    - foreign_key_checks가 비활성화되면 외래키 관계의 부모 테이블에 대한 작업(ON DELETE CASCADE와 ON UPDATE CASCADE 옵션)도 무시하게 된다.

      

  - foreign_key_checks 시스템 변수는 적용 범위를 GLOBAL과  SESSION  모두로 설정 가능한 변수다.

    - 이런 작업을 할 떄는 현재 작업을 실행하는 세션에서만 외래 키 체크 기능을 멈추게 해야 한다.

      

    - SESSION  키워드를 명시하지 않으면 자동으로 현재 세션의 설정만 변경하기 때문에 다음 두 명령은 동일한 효과를 낸다. 

    ```mysql
    > SET foreign_key_checks=OFF;
    > SET SESSION foreign_key_checks=OFF;
    ```



<br>

***

### MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능

  

- 잠금을 사용하지 않는 일관된 읽기를 제공하는데에 가장 큰 목적이 있다.

  

- InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현하는데 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

  

- 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

  

- 격리 수준(Isolation Level)이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 확인해 보자.



```sql
CREATE TABLE memeber (
	m_id 		INT NOT NULL,
  m_name	VARCHAR(20) NOT NULL,
  m_area  VARCHAR(100) NOT NULL,
  PRIMARY KEY(m_id),
  INDEX ix_area (m_area)
)

INSERT INTO member(m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
COMMIT:
```

- INSERT 문이 실행되면 데이터베이스의 상태는 아래와 같이 바뀐다.

![스크린샷 2021-11-29 오전 10 29 32](https://user-images.githubusercontent.com/50399804/147019581-89f11780-3699-45fc-9b2c-601f11b246f8.png)



- member 테이블에 UPDATE 문장이 실행될 때는 아래와 같이 변경 된다.

```sql
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```

![KakaoTalk_Photo_2021-11-29-10-28-31](https://user-images.githubusercontent.com/50399804/147019968-879f2583-4a50-412b-abe9-d9c902d8ae42.jpeg)

- UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀은 새로운 값이 '경기'로 업데이트된다.

  

- 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 있고 아닐 수도 있다.

  (InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방하다)

  

- 아직 Commit 되지 않은 상태에서 레코드를 조회하면 어디에 있는 데이터를 조회할까?

  - MySQL 서버의 시스템 변수(transaction_isolation)에 설정된 격리 수준(Isolation Level)에 따라 다르다.

    - 격리 수준이 READ_COMMITED 인 경우에는 InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환한다.

      - 데이터가 Commit 되었든 아니든 변경된  상태의 데이터를 반환한다.

        

    - 그 이상의 격리 수준인 경우에는 아직 Commit되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경 하기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다, 

    

- 위와 같은 과정을 DBMS에서는 MVCC 라고 표현한다.

  - 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조를 말한다.

  

  - 한 개의 데이터로 예시를 들었지만 관리해야 하는 예전 버전의 데이터는 무한히 많아질 수 있다.

    (트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리되어야 하며, 자연히 Undo 영역이 저장되는 시스템 테이블 스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.)

  

- 지금 상태에서 Commit 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.

  - 하지만, Rollback을 실행하면 InnoDB는 UnDo 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, Undo 영역의 내용을 삭제해버린다.

    

  - Commit이 된다고 Undo 영역의 백업 데이터가 항상 바로 삭제 되는 것은 아니다. Undo 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제 된다.

  

<br>

***

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.

  

- 잠금을 걸지 않기 때문에 InnoDB 에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.

  

- 격리 수준이 SERIALIZABLE 이 아닌 다른 수준인 경우, INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 벼경 작업과 관계없이 항상 잠금을  대기하지 않고 바로 실행된다.

  

- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 읽기 작업을 방해하지 않는다.

  - 이를 '잠금 없는 일관된 읽기' 라고 표현하며, InnoDB 에서는 변경되기 전의 데이터를 읽기 위해 Undo 로그를 사용한다.

![KakaoTalk_Photo_2021-11-29-10-49-35](https://user-images.githubusercontent.com/50399804/147021344-12f32be2-49b4-428d-8ddd-3a126a02cef1.jpeg)



- 오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다.
  - 따라서 트랜잭션이 시작되었다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.



<br>

***

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.

  

- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 강제 종료한다.

  

- 이때, 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 Undo 로그 양이며, Undo 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.

  - 트랜잭션이 Undo 레코드를 적게 가졌다는 이야기는 롤백을 해도 Undo 처리를 해야 할 내용이 적다는 것이며, 트랜잭션 강제 롤백으로 인해 MySQL 서버의 부하도 덜 유발하기 때문이다.

    

- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금([LOCK TABLES 명령](https://myinfrabox.tistory.com/75)으로 잠긴 테이블)은 볼 수가 없어서 데드락 감지가 불확실할 수도 있는데, [innodb_table_locks 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_table_locks)를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금 까지 감지할 수 있게 된다.

  - 특별한 이유가 없다면 innodb_table_locks 시스템 변수를 활성화하자.

    

- 일반적인 서비스에서 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않는다.

  

- 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.

  

- 데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾게 된다.

  

- 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 된다.

  - 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

    

  - 이런 문제점을 해결하기 위해 MySQL 서버는 [innodb_deadlock_detect 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_deadlock_detect)를 제공한다.

    - OFF로 설정하면 데드락 감지 스레드는 더는 작동하지 않게 된다.

      - 작동하지 않을 경우, InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황(데드락 상황)이 발생해도 누군가가 중재를 하지 않기 때문에 무한정 대기하게 될 것이다.

        

    - 하지만 [innodb_lock_wait_timeout 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout)를 활성화하면 이런 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 된다.

      - 초 단위로 설정할 수 잇으며, 잠금을 설정할 시간 동안 획득하지 못하면 쿼리는 실패하고 에러를 반환한다.

        

  - 데드락 감지 스레드가 부담되어 innodb_deadlock_detect 를 OFF 로 설정해서 비활성화하는 경우라면 innodb_lock_wait_timeout을 기본 값이 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다.



<br>

***

### 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재되어 있음

  - MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행

    

- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않음

  

- 하지만 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못 하는 경우도 발생할 수 있는데, 일단 한 번 문제가 생기면 복구하기가 쉽지 않다.

  

- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.

  - 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료되어 버린다.

    

  - 이때 MySQL 서버의 설정 파일에 [innodb_force_recovery 시스템 변수](https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery)를 설정해서 MySQL 서버를 시작해야 한다.

    - 이 설정값은 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다.

      - InnoDB의 로그 파일이 손상되었다면 6으로 설정하고 MySQL 서버를 기동

        

      - InnoDB 테이블의 데이터 파일이 손상되었다면 1로 설정하고 MySQL 서버를 기동

        

      - 어떤 부분이 문제인지 알 수 없는 경우, Innodb_force_recovery 설정 값을 1부터 6까지 변경하면서, MySQL을 재시작해 보자.

        - innodb_force_recovery 값이 커질수록 그만큼 심각한 상황이어서 데이터 손실 가능성이 커지고 복구 가능성이 적어진다.

          

- MySQL 서버가 기동이 되고, InnoDB 테이블이 인식된다면 [mysqldump](https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html) 를 이용해 데이터를 가능한 만큼 백업하고, 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.



- innodb_force_recovery 의 시스템 변수 변경을 통해 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다.

  

- 백업이 있다면 마지막 백업으로 데이터베이스를 새로 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있다.

  

- 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있다.

  

- 백업은 있지만 복제의 바이너리 로그가 없거나 손실됐다면 마지막 백업 시점까지만 복구할 수 있다.



> 바이너리 로그란?
>
> [MySQL 공홈](https://dev.mysql.com/doc/refman/5.6/en/binary-log.html)
>
> 
>
> https://myinfrabox.tistory.com/20

 

<br>

***

### InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간

  

- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 한다.

  

- 일반적인 애플리케이션에서 INSERT, UPDATE, DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다.

  

- 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.



<br>



- __버퍼 풀의 크기 설정__

  - 일반적으로 전체 물리 메모리의 80% 정도를 InnoDB의 버퍼 풀로 설정하라는 내용의 게시물도 있는데, 그렇게 단순하게 설정해서 되는 값은 아니며, 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야 한다.

    

  - MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독특한 경우, 레코드 버퍼가 상당한 메모리를 사용하기도 한다.

    - 레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간을 말한다.

      

    - 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수도 있다.

      

    - MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정할 수 없으며, 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라서 결정된다.

      

    - 이 공간은 동적으로 해제되기도 하므로 정확히 필요한 메모리공간의 크기를 계산할 수가 없다.

    

  - [MySQL 5.7 버전부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html)되어 가능하면 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 방법이 최적이다.

    - 운영체제의 전체 메모리공간이 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정하고 나머지 메모리 공간은 MySQL 서버와 운영체제, 그리고 다른 프로그램이 사용할 수 잇는 공간으로 확보해주는 것이 좋다.

      

    - 전체 메모리 공간이 그 이상이라면 InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올라가면서 최적점을 찾는다.

      - 운영체제의 전체 메모리 공간이 50GB 이상이라면, 대략 15GB에서 30GB 정도를 운영체제와 다른 응용 프로그램을 위해 남겨두고, 나머지를 InnoDB 버퍼 풀로 할당하자.

    

  - 버퍼 풀의 크기 변경은 크리티컬한 변경이므로 가능하면 MySQL 서버가 한가한 시점을 골라서 진행하는 것이 좋다.

    

  - InnoDB 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 가능하면 버퍼 풀의 크기를 줄이는 작업은 하지 않도록 주의하자.

    - 크기를 동적으로 변경하다면 반드시 MySQL 메뉴얼의 내용을 숙지하고 진행하도록 하자.

    

  - InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔는데, 이런 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선됐다.

    - 버퍼 풀이 여러 개의 작은 버퍼 풀로 쪼개지면서 개별 버퍼 풀 전체를 관리하는 잠금(세마포어) 자체도 경합이 분산되는 효과를 내게 되는 것이다.

      

    - innodb_buffer_pool_instances 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있는데, 각 버퍼 풀을 버퍼 풀 인스턴스라고 표현한다.

      - 기본적으로 버퍼 풀 인스턴스의 개수는 8개로 초기화되지만 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만이라면 버퍼 풀 인스턴스는 1개만 생성된다.

        

      - 버퍼 풀로 할당할 수 있는 메모리 공간이 40GB 이하 수준이라면 기본 값인 8을 유지하고, 메모리가 크다면 버퍼 풀 인스턴스당 5GB 정도가 되게 인스턴스 개수를 설정하는 것이 좋다.

    

    

  <br>

  

- __버퍼 풀의 구조__

  ![innodb-buffer-pool-list](https://user-images.githubusercontent.com/50399804/147584124-ee94be39-1dd7-410f-a25f-0a463bc127c9.png)

  

  ![제목 없음](https://user-images.githubusercontent.com/50399804/147584460-eaca1641-93b0-4bf2-87d5-8d101aa8ff25.png)

  - InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리공간을 페이지 크기 ([innodb_page_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size))의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.

    

  - 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU(Least Recently Used) 리스트와 플러시(Flush) 리스트, 그리고 프리(Free) 리스트라는 3개의 자료 구조를 관리한다.

    - 프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.

      

    - LRU 리스트는 위의 그림과 같은 구조를 띠며, 엄밀하게 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태라고 보면 된다.

      

  - 그림에서 Old Sublist 영역은 LRU에 해당하고, New Sublist 영역은 MRU 정도로 이해하면 된다.

    

  - LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다.

    

  - __InnoDB 스토리지 엔진에서 데이터를 찾는 과정__ 은 대략 다음과 같다.

    1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사

       1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색

          

       2. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색

          

       3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급

          

    2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가

       

    3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동

       (Read Ahead와 같이 대량 읽기의 경우, 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우 MRU로 이동되지 않음)

       

    4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고, 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.

       

    5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

       

  - 처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면, 그 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 되고, 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국은 InnoDB 버퍼 풀에서 제거될 것이다.



<br>

***

### 버퍼 풀과 리두 로그

![제목 없음](https://user-images.githubusercontent.com/50399804/147585447-e8156176-d38c-4a5d-a3c6-45f33932679b.png)

- InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다.

  

- 물론 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간이라면 더는 버퍼 풀 크기를 늘려도 성능에 도움이 되지 않겠지만, 그렇지 않다면 디스크의 데이터가 버퍼 풀 메모리로 적재되면 성능이 좋아질 것이다.

  

- 하지만, InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 2가지 용도가 있는데, 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상시키는 것이므로 __InnoDB 버퍼 풀의 쓰기 버퍼링 기능까지 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야 한다.__

  

- InnoDB의 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)와 함께 INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더티 페이지(Dirty Page)도 가지고 있다.

  - 더티 페이지는 디스크와 메모리(버퍼 풀)의 데이터 상태가 다르기 때문에 언제가는 디스크로 기록되어야 한다.

    

- 하지만, 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것은 아니라 InnoDB 스토리지 엔진에서 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다.

  

- 즉, 데이터 변경이 계속 발생하면 리두 로그 파일에 기록되었던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.

  

- InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야 하는데, 재사용 불가능한 공간을 활성 리두 로그(Active Redo Log)라고 한다.

  - 위 그림에서 화살표를 가진 엔트리들이 활성 리두 로그 공간인 것이다.



- 나머지 자세한 내용은 책을 참조하자.



> 리두 로그(Redo Log)란?
>
> https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html
>
> https://dus815.tistory.com/entry/Mysql-Redo-Log-%EB%9E%80
>
> 
>
> 언두 로그(Undo Log)와 구분하도록 하자.







<br>

***

### 버퍼 풀 플러시(Buffer Pool Flush)

- [플러시](https://dev.mysql.com/doc/refman/8.0/en/flush.html) 란 변경 사항을 데이터베이스에 기록하기 위해, 메모리 영역이나 이미 디스크 스토리지 영역에 버퍼해 놓는데(버퍼풀, 리두 로그, 언두 로그) 이를 비우는 작업을 말한다.

  - 메모리 공간이 꽉차 자유 공간이 필요하다거나, 트랜잭션으로 인한 변경이 끝나 Commit이 수행될때를 예로 들 수 있다.(예시)

    

- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화 하기 위해, 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다.

  - 플러시 리스트(Flush_list) 플러시

    - 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야 한다.

      

    - 오래된 리두 로그 공간이 지워지려면 반드시 InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화되어야 한다.

      

    - 플러시 리스트(Flush_list) 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다.

      

    - 자세한 설정 값이나 방법은 책을 참조하자.

    

  - LRU 리스트(LRU_list) 플러시

    - InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU 리스트(LRU_list) 플러시 함수가 사용된다.

      

    - LRU 리스트의 끝부분부터 시작해서 최대 innodb_lru_scan_dept 시스템 변수에 설정된 개수만큼의 페이지들을 스캔하고 더티 페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다.

      - InnoDB 버퍼 풀 인스턴스별로 최대 innodb_lru_scan_depth 개수만큼 스캔하기 때문에 실질적으로 LRU 리스트의 스캔은

        (innodb_buffer_pool_instances * innodb_lru_scan_depth) 수만큼 수행한다.

    

- MySQL 5.6 버전까지는 InnoDB 스토리지 더티 페이지 플러시 기능이 그다지 부드럽게 처리되지 않았다.

  - 급작스럽게 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 받는 경우가 많았다.

    

  - 8.0버전으로 업그레이드되면서 대부분의 서비스에서는 더티 페이지를 디스크에 동기화하는 부분(더티 페이지 플러시)에서 예전과 같은 디스크 쓰기 폭증 현상을 발생하지 않았다.



<br>

***

### 버퍼 풀 상태 백업 및 복구

- InnoDB 서버의 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연관되어 있다. 

  - 쿼리 요청이 매우 빈번한 서버를 셧다운했다가 다시 시작하고 서비스를 시작하면 쿼리 처리 성능이 평상시보다 1/10도 안 되는 경우가 대부분일 것이다.

  

- 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비되어 있으므로 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있기 때문이다.

  

- 이렇게 디스크의 데이터 버퍼 풀에 적재되어 있는 상태를 워밍업(Warming Up)이라고 표현하는데, 버퍼 풀이 잘 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적이다.

  - 5.5 버전에서는 점검을 위해 서버를 셧다운했다가 다시 시작하는 경우, 서비스를 오픈하기 전에 강제 워밍업을 위해 주요 테이블과 인덱스에 대해 풀 스캔을 한 번씩 실행하고 서비스를 오픈했었다.

    

  - 5.6 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입되었다. 서버 점검이나 기타 작업을 위해 서버를 재시작해야 하는 경우 서버를 셧다운하기 전에 다음과 같이 innodb_buffer_pool_dump_now 시스템 변수를 이용해 InnoDB 버퍼 풀의 상태를 백업할 수 있다.

    

  - 그리고, 서버를 다시 시작하면 innodb_buffer_pool_load_now 시스템 변수를 이용해 백업된 버퍼 풀의 상태를 다시 복구할 수 있다.

  ```mysql
  -- MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
  > SET GLOBAL innodb_buffer_pool_dump_now = ON;
  
  -- MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
  > SET GLOBAL innodb_buffer_pool_load_now = ON;
  ```

  

- 버퍼 풀의 백업은 데이터 디렉터리에 id_buffer_pool 이라는 이름의 파일로 생성되는데, 실제 이 파일의 크기를 보면 아무리 InnoDB 버퍼 풀이 크다 하더라도 몇십 MB 이하인 것을 알 수 있다.

  - InnoDB 스토리지 엔진이 버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문이다.

    

  - 그래서 버퍼 풀의 백업은 매우 빨리 완료된다. 하지만 백업된 버퍼 풀의 내용을 다시 버퍼 풀로 복구하는 과정은 InnoDB 버퍼 풀의 크기에 따라 상당한 시간이 걸릴 수도 있다. 백업된 내용에서 각 테이블의 데이터 페이지를 다시 디스크에서 읽어와야 하기 떄문이다.

    

  - 그래서 InnoDB 스토리지 엔진은 버퍼 풀을 다시 복구하는 과정이 어느 정도 진행되었는지 확인할 수 있게 상태 값을 제공한다.

  ```MYSQL
  > SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G
  ```

  

  - 버퍼 풀 적재 작업에 너무 시간이 오래 걸려서 중간에 멈추고자 한다면 innodb_buffer_pool_load_abort 시스템 변수를 이용하면 된다.

    - 복구하는 작업은 상당히 많은 디스크 읽기를 필요로 하기 때문에 버퍼 풀 복구가 실행 중인 상태에서 서비스를 재개하는 것은 좋지 않은 선택일 수도 있다. 그래서 버퍼 풀 복구 도중에 급히 서비스를 재시작해야 한다면 다음과 같이 버퍼 풀 복구를 멈출것을 권장한다.

    ```mysql
    > SET GLOBAL innodb_buffer_pool_load_abort=ON;
    ```

  

- 수동으로 InnoDB 버퍼 풀의 백업과 복구를 살펴보았는데, 사실 이 작업을 수동으로 하기는 쉽지 않다. 다른 작업을 위해 MySQL 서버를 재시작하는 경우 해야 할 작업에 집중한 나머지 버퍼 풀의 백업과 복구 과정을 잊어버리기 십상이다.

  

- InnoDB 스토리지 엔진은 MySQL 서버가 셧다운 되기 전에 버퍼 풀의 백업을 실행하고, MySQL 서버가 시작되면 자동으로 백업된 버퍼 풀의 상태를 복구할 수 있는 기능을 제공한다.

  - 백업과 복구를 자동화하려면 innodb_buffer_pool_dump_at_shudown 과 innodb_buffer_pool_ad_at_startup 설정을 MySQL 서버의 설정 파일에 넣어두면 된다.



<br>

***

### 버퍼 풀의 적재 내용 확인

- MySQL 5.6 버전 부터 MySQL 서버의 information_schema 데이터베이스의 innodb_buffer_page 테이블을 이용해 InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재되어 있는지 확인할 수 있었다.

  - InnoDB 버퍼 풀이 큰 경우에는 이 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 많이 느려지는 문제가 있었다. 그래서 실제 서비스용으로 사용되는 MySQL 서버에서는 버퍼 풀의 상태를 확인하는 것이 거의 불가능했다.

    

- MySQL 8.0 버전에서는 이러한 문제점을 해결하기 위해 information_schema 데이터베이스에 innodb_cached_indexes 테이블이 새로 추가되었다.

  

- 이 테이블을 이용하면 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재되어 있는지 확인할 수 있다.

```mysql
> SELECT
  it.name table_name,
  ii.name index_name,
  ici.n_cached_pages n_cached_pages
  FROM information_schema.innodb_tables it
  INNER JOIN information_schema.innodb_indexes ii ON ii.table_id = it.table_id
  INNER JOIN information_schema.innodb_cached_indexes ici ON ici.index_id = ii.index_id
  WHERE it.name = CONCAT('employyes', '/', 'employees');
```



- 조금만 응용하면 테이블 전체(인덱스 포함) 페이지 중에서 대략 어느 정도 비율이 InnoDB 버퍼 풀에 적재되어 있는지  확인할 수 있다.
  - 아직 개별 인덱스별로 전체 페이지 개수가 몇 개인지는 사용자에게 알려주지 않기 떄문에 테이블의 인덱스별로 페이지가 InnoDB  버퍼 풀에 적재된 비율은 확인할 수가 없다.

```mysql
> SELECT
	(SELECT SUM(ici.n_cached_pages) n_cached_pages
     FROM information_schema.innodb_tables it
     INNER JOIN information_schema.innodb_indexes ii ON ii.table_id = it.table_id
     INNER JOIN information_schema.innodb_cached_indexes ici ON ici.index_id = ii.index_id
     WHERE it.name = CONCAT(t.table_schema, '/', t.table_name)) as total_cached_pages,
    ((t.data_length + t.index_length - t.data_free)/@@innodb_page_size) as total_pages
    FROM information_schema.tables t
    WHERE t.table_schema='employees'
      AND t.table_name='employees';
    
```
