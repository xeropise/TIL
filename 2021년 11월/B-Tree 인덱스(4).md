### 인덱스 풀 스캔

![image (4)](https://user-images.githubusercontent.com/50399804/145819239-892995ad-320d-4b44-9ae1-076045a61e2c.png)



- 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만, 인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.

  - 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우, 인덱스 풀 스캔 방식이 사용된다.

    

  - 인덱스 (A, B, C) 컬럼의 순서로 만들어져 있지만, 쿼리의 조건절은 B 컬럼이나 C 컬럼으로 검색하는 경우다.

    

- 일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적이다.

  

- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.

  

- 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이방식으로 처리되지 않는다.

  

- 인덱스 레인지 스캔보다는 빠르지 않지만, 테이블 풀 스캔보다는 효율적이다. 테이블의 레코드를 읽을 필요 없이, 인덱스에 포함된 컬럼만으로 처리가 가능하기 때문이다.

  - 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은 테이블 풀 스캔보다 적은 디스크 I/O로 쿼리를 처리할 수 있다.



<br>

***

### 루스 인덱스 스캔

![loose Index Scan](https://user-images.githubusercontent.com/50399804/145923136-3df15e23-5813-4959-96f4-02c3cf8b0339.png)

- 앞서 설명한, 인덱스 레인지 스캔, 인덱스 풀스캔을 의미적으로 타이트한 인덱스 스캔이라한다면, 루스 인덱스 스캔은 말 그대로 느슨하게 또느 듬성듬성하게 인덱스를 읽는 것을 의미한다.

  

- MySQL 5.7 버전까지는 루스 인덱스 스캔 기능이 많이 제한적이었지만, 8.0 버전부터는 다른 상용 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화를 조금씩 지원하기 시작했다.

  

- 루스 인덱스 스캔은 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.

  - 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용한다.



<br>

***

### 인덱스 스킵 스캔

![KakaoTalk_Photo_2021-12-14-12-20-06](https://user-images.githubusercontent.com/50399804/145927113-7982907a-2c0d-425a-b3a2-ed83fe200b26.jpeg)

- 데이터베이스 서버에서 인덱스의 핵심은 값이 정렬되어 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다.

  

- employees 테이블에 다음과 같은 인덱스를 생성해보자.

```sql
> ALTER TABLE employees ADD INDEX ix_gender_birthdate(gender, birth_date);
```



- 위의 인덱스를 사용하려면 WHERE 조건절에 gender 컬럼에 대한 비교 조건이 필수다.

```sql
-- 인덱스를 사용하지 못하는 쿼리
> SELECT * FROM employees WHERE birth_date >= '1965-02-01';

-- 인덱스를 사용할 수 있는 쿼리
> SELECT * FROM employees WHERE gender = 'M' AND birth_date >= '1965-02-01';
```

> 주로 이런 경우에는 birth_date 컬럼부터 시작하는 인덱스를 새로 생성해야만 했다.



- MySQL 8.0 버전 부터는 옵티마이저가 gender 컬럼을 건너뛰어서 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다.

  - 물론 이전 버전에서도 비슷한 최적화를 수행하는 루스 인덱스 스캔 기능이 있었지만, 루스 인덱스 스캔은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용할 수 있었다.

    

  - MySQL 8.0 버전에 도입된 인덱스 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨씬 넓어졌다.



- 다음의 커맨드로 인덱스 스킵 스캔 기능을 비활성화하고, MySQL 8.0 이전 버전에서는 어떤 실행 계획으로 처리됐는지 한번 살펴보자.

```sql
> SET optimizer_switch='skip_scan=off';

> EXPLAIN
	SELECT gender, birth_date
	FROM employees
	WHERE birth_date >= '1965-02-01';
	
	id   table  		type  	key  									Extra
	1    employees  index		ix_gender_birthdate		Using where; Using Index
```



- 위의 쿼리의 경우, geneder 컬럼에 대한 조건없이 birth_date 컬럼의 비교 조건만 가지고 있기때문에 ix_gender_birthdate 인덱스를 효율적으로 이용할 수 없다.

  - 여기서 효율적이란 말은 인덱스에서 꼭 필요한 부분만 접근하는 것을 의미한다.

    

  - type 컬럼이 index 라고 표시된 것은 인덱스를 처음부터 끝까지 모두 읽음 (인덱스 풀 스캔)의 의미이므로 인덱스를 비효율적으로 사용한 것이다.



- 인덱스 스킵 스캔을 활성화하고, 동일 쿼리의 실행 계획을 다시 확인해 보자.

```sql
> SET optimizer_switch='skip_scan=on';

> EXPLAIN
	SELECT gender, birth_date
	FROM employees
	WHERE birth_date >= '1965-02-01';
	
 id   table  	type  	        key  				Extra
 1    employees  range		ix_gender_birthdate		Using where; Using Index for skip scan
```



- 이번엔 쿼리의 실행 계획에서 type 컬럼의 값이 'range' 로 표시됐는데, 이는 인덱스에서 꼭 필요한 부분만 읽었다는 것을 의미한다.

  

- Extra에 'Using Index for skip scan' 이라는 문구가 표시됐는데, ix_gender_birthdate 인덱스에 대해 인덱스 스킵 스캔을 활용해 데이터를 조회했다는 것을 의미한다.

  - MySQL 옵티마이저는 우선 gender 컬럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 컬럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.

    

- 인덱스 스킵 스캔은 8.0에 새로이 도입된 기능이어서 아직 다음과 같은 단점이 있다.

  - WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함

    - 유니크한 값의 개수가 매우 많다면 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해져 성능이 떨어진다.

    

  - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)

    - 아래의 쿼리의 경우, SELECT 에서 * 를 조회하기 때문에 인덱스 컬럼이외의 컬럼도 필요하기 때문에 인덱스 스킵 스캔을 사용하지 못하고

      풀테이블 스캔으로 실행 계획을 수립하게 된다.

  ```sql
  > SELECT
  	*
  	FROM employees
  	WHERE birth_date >= '1965-02-01';
  ```

  

<br>

***

### 다중 컬럼(Multi-column) 인덱스

![99C8FE365B73BEE922](https://user-images.githubusercontent.com/50399804/145928510-fa6882d9-a401-4729-96e1-4301d0e00629.png)

- 실제 서비스용 데이터베이스에서는 2개 이상의 컬럼을 포함하는 인덱스가 더 많이 사용 된다.

  

- 2개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스(복합 컬럼 인덱스)라고 하며, 2개 이상의 컬럼이 연결되었다고 해서 "Concatenated Index" 라고도 한다.

  

- 위 그림의 경우, 루트 노드는 생략했으나 실제로 데이터 레코드 건수가 작은 경우에는 브랜치 노드가 없는 경우도 있을 수도 있다.

  - 하지만, 루트 노드와 리프 노드는 항상 존재한다.

    

- 인덱스의 두번째 컬럼은 첫번째 컬럼에 의존해서 정렬되어 있는 것을 볼 수 있는데, 즉, 두번째 컬럼의 정렬은 첫번째 컬럼이 똑같은 레코드에서만 의미가 있다는 것이다.

  - 다중 컬럼 인덱스에서는 인덱스 내에서 컬럼의 위치가 상당히 중요하며, 그것을 아주 신중히 결정해야 한다.
  - (col1, col2, col3) 인덱스에서 (col2, col3) 만 사용하거나 (col3, col2, col1) 으로 조건절에 작성하는 경우, 이 순서에 따라 옵티마이저가 인덱스를 사용하지 않을 수도 있다.
