### 인덱스 키 변경

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다.

  

- B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

  

- 키 값의 변경 때문에 발생하는 B-Tree 인덱스 키 값의 삭제와 추가 작업은 앞에 1번 문서에서 설명한 바와 같이 진행되는 데, 결국 인덱스 키 값을 변경하는 작업은 기존 인덱스 키 값을 삭제 한 후, 새로운 인덱스 키 값을 추가하는 작업으로 처리되고, InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리 될 수 있다.



<br>

***

### 인덱스 키 검색

- 데이터 수정,삭제,삽입 등의 성능을 희생하면서 인덱스를 구축하는 이유는 바로 빠른 검색 때문이다.

  

- 인덱스를 검색하는 작업은 B-Tree 의 루트 노드부터 시작해 브런치 노드를 거쳐, 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 '트리 탐색' 이라고 한다.

  

- 인덱스 트리 탐색은 SELECT 에서만 사용하는 것이 아니라, UPDATE 나 DELETE 를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용된다.

  

- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에 사용할 수 있다.

  

- 부등호("<,>") 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.

  

- 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다.

  

- 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니므로, 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree 의 장점을 이용할 수 없으므로 주의하자.

  

- InnoDB 스토리지 엔진에서는 인덱스가 더 특별한 의미가 있는데, InnoDB 테이블에서 지원하는 [레코드 잠금이나 넥스트 키락(갭락)](https://rosebud90.tistory.com/entry/InoDB-%EC%9E%A0%EA%B8%88-2-record-lock-gap-lock-Next-Key-Lock-Insert-Intention-Lock-Auto-Inc-Lock)이 검색을 수행한 인덱스를 잠근 후, 테이블의 레코드를 잠그는 방식으로 구현되어 있다.

  - UPDATE나 DELETE 문장이 실행될 때, 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

    

  - 심지어 테이블의 모든 레코드를 잠글 수도 있다.

    

  - InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다. 



<br>

***

### B-Tree 인덱스 사용에 영향을 미치는 요소

- B-Tree 인덱스는 인덱스를 구성하는 컬럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

  

- __인덱스 키 값의 크기__

  ![image](https://user-images.githubusercontent.com/50399804/145802598-c199f6b4-3996-4da2-9eb9-b27c86fb41a5.png)

  - InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 

    

  - 인덱스도 결국은 페이지 단위로 관리되며, 루트와 브런치, 그리고 리프 노드를 구분한 기준이 바로 페이지 단위다.

    

  - 일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조로 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 개수를 결정할 수 있다.

    

  - MySQL 5.7 버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 innodb_page_size 시스템 변수를 이용해 4KB ~ 64KB 사이의 값을 선택할 수 있지만, 기본값은 16KB이다.

    

  - 위 그림을 기준으로 하나의 인덱스 페이지(16KB)에 몇 개의 키를 저장할 수 있을까?

    - 16 * 1024/(16+12) = 585 개 저장할 수 있다. [ (페이지 전체 바이트) / (인덱스 키 바이트 + 자식 노드 주소)  ]

      

    - 즉, 자식 노드를 585개를 가질 수 있는 B-Tree가 된다.

      

  - 인덱스의 키 값이 커지면 한 페이지에 인덱스 키를 더 적게 저장하게 된다.

    - 키 값이 32바이트라고 하면, 16*1024/(32+12) = 372 개

      

  - 만약 SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한번으로 해결될 수도 있지만, 후자는 최소한 2번 이상 디스크로부터 읽어야 한다.

    

  - 결국 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.

    

  - 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다.

    - 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리에

      캐시해 둘 수 있는 레코드 수는 줄어든다. (메모리의 효율이 떨어지는 결과)



<br>

***

### B-Tree 깊이

![1_IteSc8bf_UvedJ1wL-wDyg](https://user-images.githubusercontent.com/50399804/145804823-99f1ca9f-2b63-415a-aa46-774ab58c5b0d.jpeg)

- B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.

  

- 인덱스 키 값의 평균 크기가 늘어나면 어떤 현상이 추가로 더 발생하는지 알아보자.

  - 인덱스의 B-Tree의 깊이가 3인 경우, 최대 몇개의 키 값을 가질 수 있을지 비교해 보자.

    - 키 값이 16바이트인 경우, 최대 2억 (585 * 585 * 585) 개 정도의 키 값을 담을 수 있다.

      

    - 키 값이 32바이트로 늘어나면 5천만 (372 * 372 * 372) 개로 줄어든다.

      

- B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.

  - 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어진다. 

    

  - 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 일기가 더 많이 필요하게 된다는 것을 의미한다.

    

- 인덱스의 키 값의 크기는 가능하면 작게 만드는 것이 좋다는 것을 강조하기 위함이며, 실제로는 아무리 대용량 데이터베이스라도 B-Tree의 깊이가 5단계 이상까지 깊어지는 경우는 없다.

