### B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다.

  

- 하지만 어떤 인덱스가 오름차순으로 생성됐다고 해서 그 인덱스를 오름차순으로만 읽을 수 있다는 뜻은 아니다.

  

- 사실 그 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로도 사용될 수 있다.

  

- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.



<br>

***

### 인덱스의 정렬

- 일반적인 상용 DBMS 엥서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 컬럼의 정렬을 오름차순 또는 내림차순으로 설정할 수 있다.

  

- MySQL 5.7 버전까지는 컬럼 단위로 정렬 순서를 혼합(ASC 와 DESC 혼합)해서 인덱스를 생성할 수 없었다.

  - 이런 문제점을 해결하기 위해 숫자  컬럼으 경우 -1을 곱한 값을 저장하는 우회 방법을 사용하기도 했다.

    

- MySQL 8.0 버전부터는 다음과 같은 형태의 정렬 순서를 홉한한 인덱스도 생성할 수 있게 됐다.

  - 5.7 버전에서도 오름차순 컬럼과 내림차순 컬럼을 혼합한 인덱스를 생성가능하게 한거 같으나 문법만 제공했을 뿐이지 

    실제론 오름차순 정렬으로만 인덱스가 생성되었다.

```sql
CREATE INDEX ix_teamname_userscroe ON employees (team_name ASC, user_score DESC);
```



<br>

***

### 인덱스 스캔 방향

![109612518-307ebd80-7b73-11eb-8d81-a6918b3ba8b7](https://user-images.githubusercontent.com/50399804/145992063-b064fb3e-89ff-409c-b4ec-462f2bd1085b.png)

- 인덱스는 항상 오름차순으로만 정렬되어 있지만, 인덱스를 최소값부터 읽으면 오름차순으로 가져올 수 있고, 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 옵티마이저는 이미 알고 있다.

  

  ```sql
  > SELECT
  	FROM employees
  	ORDER BY first_name DESC
  	LIMIT 1;
  ```

  

- 위의 쿼리의 경우 인덱스를 역순으로 접근해 첫번째 레코드만 읽으면 된다.

  - 즉, 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

    

- 오름차순으로 생성된 인덱스를 정순으로 읽으면 출력되는 결과 레코드는 자동으로 오름차순으로 정렬된 결과가 되고, 역순으로 읽으면 그 결과는 내림차순으로 정렬된 상태가 되는 것이다.

  

  ```mysql
  > SELECT * FROM employees WHERE first_name >= 'Anneke'
    ORDER BY first_name ASC LIMIT 4;
    
  > SELECT * FROM employees ORDER BY first_name DESC LIMIT 5;  
  ```

  

- 위의 첫번째 쿼리는 first_name 컬럼에 정의된 인덱스를 이용해 "Anneke" 라는 레코드를 찾은 후, 정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가져오면 아무런 비용을 들이지 않고도 원하는 정렬효과를 얻을 수 있다.

  

- 두번째 쿼리는 이와 반대로 employees 테이블의 first_name 컬럼에 정의된 인덱스를 역순으로 읽으면서 처음 다섯 개의 레코드만 가져오면 된다.

  

- 쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.



<br>

***

### 내림차순 인덱스

- 특정 컬럼을 역순으로 정렬하는 요건만 있다면, 다음 2개 인덱스 중에서 어떤 것을 선택하는 것이 좋을까? 모두 동일한 성능일까?

```sql
> CREATE INDEX ix_firstname_asc ON employees (first_name ASC);
> CREATE INDEX ix_firstname_desc ON employees (first_name DESC);
```



```mysql
> SELECT * FROM t1 ORDER BY first_name ASC LIMIT 12619775, 1;
-- 1 row in set (4.15 sec)

> SELECT * FROM t1 ORDER BY first_name DESC LIMIT 12619775, 1;
-- 1 row in set (5.35 sec)
```



- 1천 2백여만 건을 스캔하는데, 1.2초, 비율로 따지면 역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 더 시간이 걸리는 것을 확인할 수 있다.

  

- 하나의 인덱스를 정순으로 읽느냐 또는 역순으로 읽느냐에 따라 이런차이가 발생한다는 것은 쉽게 이해하기 어렵다.

  

- MySQL 서버의 InnoDB 스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지(블록) 간의 양방향 연결 고리(Double linked list)를 통해 전진하느냐 후진하느냐의 차이만 있지만, 실제 내부적으로는 InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 다음의 2가지 이유가 있다.

  - 페이지 잠금(lock) 이 인덱스 정순 스캔(Forward index scan)에 적합한 구조

    

  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조



> - InnoDB 페이지 내부에서 레코드들이 정렬 순서대로 저장되어 있는 것처럼 표시되어 있지만 실제로 InnoDB 페이지는 힙(Heap)처럼 사용되기 때문에 물리적으로 저장이 순서대로 배치되지는 않는다.
>
>   
>
> - 각 데이터 페이지 (InnoDB 스토리지 엔진에서 데이터 파일은 PK 자체라는 것에 주의하자) 나 인덱스 페이지의 엔트리 (데이터 레코드 또는 인덱스 키) 는 키 값과 데이터를 가지는 데, 인덱스의 루트 또는 브랜치 노드라면 자식 노드의 주소를 가진다.
>
>   
>
> - PK에서 리프 노드의 "데이터"는 실제 레코드의 컬럼 값들이며, 세컨더리 인덱스 페이지에서는 PK 키 값을 가진다.



- 역순으로 정렬하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면, 내림차순 인덱스를 굳이 고려할 필요는 없어 보인다.

  - 하지만, 많은 레코드를 조회하면서 빈번하게 실행된다면 정렬 방향에 맞게 인덱스를 사용하는 것이 좋아 보인다.

    

  - 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다.