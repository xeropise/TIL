### 선택도(기수성)

- 인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 말한다.

  

- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다. 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 떄문에 그만큼 빠르게 처리된다.

  

- 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.

  - 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계해야 한다.



<br>

***

### 읽어야 하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.

  - 가령, 테이블에 레코드가 100만 건이 저장되어 있는데, 그중에서 50만 건을 읽어야하는 쿼리가 있다고 하자.

    - 풀테이블 스캔의 경우, 모두 읽어 필요 없는 50만 건을 버린다.

      

    - 인덱스 스캔의 경우, 필요한 50만 건만 읽어온다.

      

  - 위 두 경우중 어느게 효율적일지 판단해야 한다.

    

- 인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있다.

  - DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 많이 드는 작업인 것으로 예측한다.

    - RDBMS 서버 종류별로 물론 차이가 있고, MySQL 서버에서 코스트 모델 설정에 따라 변경될 수 있다.

      

- 인덱스를 통해 읽어야 할 레코드의 건수(물론 옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고, 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.

  

- 100만건에서 50만건 데이터를 읽어야 한다면, 인덱스의 손익 분기점을 넘기 때문에 옵티마이저는 인덱스 스캔을 이용하지 않고, 풀테이블 스캔을 사용할 것이다.

  - 이렇게 많은 레코드를 읽을 때는 강제로 인덱스를 사용하도록 힌트를 추가해도 성능상 얻을 수 있는 이점이 없다.



<br>

***

### B-Tree 인덱스를 통한 데이터 읽기

- 어떤 경우에 인덱스를 사용하게 유도할지, 또는 사용하지 못하게 할지 판단하려면 MySQL(더 정확히는 각 스토리지 엔진)이 어떻게 인덱스를 이용(경유)해서 실제 레코드를 읽어 내는지 알아야 한다.



- __인덱스 레인지 스캔__

  ![image (3)](https://user-images.githubusercontent.com/50399804/145809673-c6d76f7c-80c2-40d8-b8f3-d3f2ea99bbe5.png)

  

  - 인덱스의 접근 방법 중 가장 대표적인 접근 방식, 인덱스 풀 스캔, 루스 인덱스 스캔의 인덱스 접근 방식보다 빠른 방법이다.

    

  - 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정되었을 때, 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다.

    

  - 루트 노드에서부터 비교를 시작해 브랜치 노드를 거쳐, 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있다.

    - 일단, 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.

      

    - 이처럼, 차례대로 쭉 읽는 것을 스캔이라고 표현한다.

      

    - 만약 스캔하다가 리프 노드의 끝까지 읽으면, 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다.

      

    - 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.

      

    - 두꺼운 선은 스캔해야 할 위치 검색을 위한 비교 작업을 의미하며, 두꺼운 화살표가 지나가는 리프 노드의 레코드 구간은 실제 스캔하는 범위를 표현한다.

      

  - 위의 경우는 실제 인덱스만을 읽는 경우면, B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데 그림은 다음과 같다.

    ![image (2)](https://user-images.githubusercontent.com/50399804/145809656-8972b377-215b-4640-b267-e03aa10b919d.png)

    

    - B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 탐색하고, 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어 나간다.

      - 중요한 것은 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온 다는 것이다.

        - 이는 별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다.

          

    - 한 가지 중요한 것은, 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.

      - 이때, 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다.

        

      - 그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.

        

    - 쿼리가 필요로 하는 데이터에 따라, 디스크의 레코드를 읽지 않아도 되는데, 이를 커버링 인덱스라고도 한다.

      - 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다.

        

    - MySQL 에서는 인덱스 탐색과 인덱스 스캔 작업이 얼마나 수행됐는지를 확인할 수 있게 다음과 같은 상태 값을 제공한다.

      ```sql
      > SHOW STATUS LIKE 'Handler_%';
      ```

      ![스크린샷 2021-11-14 오후 10 02 00](https://user-images.githubusercontent.com/50399804/145817272-a27be2a6-7d18-4dc4-b4b7-6d7776bdc036.png)

      - Handler_read_key 는 인덱스 탐색이 실행된 횟수

        

      - Handler_read_next 와 Handler_read_prev 는 인덱스 스캔 단계로 읽은 레코드 건수를 의미한다.

        

      - Handler_read_next 는 인덱스 정순으로 읽은 레코드 건수이며, Handler_read_prev 는 인덱스 역순으로 읽은 레코드 건수이다.

        

      - Handler_read_first 와 Handler_read_last 는 인덱스의 첫 번째 레코드와 마지막 레코드를 읽은 횟수를 의미하는데, MIN() 또는 MAX() 와 같이 제일 큰 값 또는 제일 작은 값만 읽는 경우 증가하는 상태 값이다.

        

      - 위 값들은 읽은 레코드 건수를 의미하는데, 실제 인덱스만 읽었는지 인덱스를 통해 테이블의 레코드를 읽었는지는 구분하지는 않는다.

        

      - 다른 지표에 대한 설명과 Handler에 대한 설명은 [여기](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jevida&logNo=221252404199) 를 참조하자.