## 인덱스

- 책의 맨 끝에 있는 찾아보기같은 색인으로  쉽게 설명할 수 있다.

  - 책의 내용은 데이터파일에 비유할 수 있다.

    

  - 책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유 될 수 있다.

    

  - 책이 ㄱ..ㄴ..ㄷ 으로 정렬하는 것처럼컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

    

- 프로그래밍의 자료 구조를 말하자면 SortedList

  - 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있어 아주 빨리 원하는 값을 찾아올 수 있다.

    - DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능

      - SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면, 

        데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과

        

- 인덱스는 데이터를 관리하는 방식(알고리즘)과 중복 값의 허용 여부 등에 따라 여러 가지로 나눠볼 수 있음

  

- 인덱스를 역할별로 구분해 본다면 프라이머리 키(Primary Key)와 보조 키(세컨더리 인덱스, Secondary Key)로 구분할 수 있다.

  - PK는 그 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미한다. 식별자라 한다. NULL 값을 허용하지 않으며, 중복을 허용하지 않는다.

    

  - PK를 제외한 나머지 모든 인덱스를 세컨더리 인덱스로 분류 한다. 

    - 유니크 인덱스는 PK와 성격이 비슷하고, PK가 없을 경우 대신 선택되어 사용되므로 대체 키라고도 하는데, NULL 을 허용하는 데에서 차이가 있다.

      

- 데이터 저장 방식(알고리즘) 별로 구분할 경우, 많은 분류가 가능하겠지만 대표적으로는  B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.

  - B-Tree 인덱스

    - 가장 일반적으로 사용하는 인덱스 알고리즘으로서, 상당히 오래전에 도입된 알고리즘

      

    - 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.

      

    - MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.

      

  - Hash 인덱스

    - 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.

      

    - 하지만, 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.

      

    - 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

> 최근엔 Fractal-Tree 인덱스나 로그 기반의 Merge-Tree 인덱스와 같은 알고리즘을 사용하는  DBMS 도 개발되고 있다.



- 데이터의 중복 허용 여부로 분류하면, 유니크 인덱스(Unique)와 유니크하지 않은 인덱스(Non-Unique)로 구분할 수 있다.

  - 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.

    

  - 유니크 인덱스에 대해 동등(=equal) 조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 찾지 않아도 된다는 것을 

    옵티마이저에게 알려주는 효과를 낸다.

    

  - 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점이 상당히 많다. 이러한 부분은 인덱스나 쿼리의 실행 계획을 살펴보면서 알 수 있다.

    

- 인덱스의 기능별로 분류해보면 전문 검색용 인덱스나 공간 검색용 인덱스 등을 예로 들 수 있다.

  - 수없이 많은 인덱스가 있겠지만, MySQL을 사용할 때는 이 두 가지만으로도 충분하다.