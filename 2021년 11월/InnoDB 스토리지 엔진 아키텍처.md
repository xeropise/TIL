## InnoDB 스토리지 엔진 아키텍처

![제목 없음](https://user-images.githubusercontent.com/50399804/146808621-374e7be5-40db-413b-8e38-3cd46e0841d1.png)



- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

  

- InnoDB 스토리지 엔진의 주요 특징들을 살펴 보자.

  

<br>

***

### PK에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다.

  - PK 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 PK의 값을 논리적인 주소로 사용한다.

    

- PK가 클러스터링 인덱스이므로 PK를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.

  

- 쿼리의 실행 계획에서 PK는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정 (다른 인덱스보다 선택될 확률이 높음)이 된다.

  

- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않아, 구조적으로 PK와 세컨더리 인덱스의 차이가 없다.

  - MyISAM에서는 PK는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.

    

  - MyISAM 테이블의 PK및 모든 인데스는 물리적인 레코드 주소 값(ROWID)을 가진다.



<br>

***

### 외래 키 지원

- 외래 키에 대한 지원은 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.

  

- 외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있는데, 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.

  

- InnoDB 에서 외래키는 부모 테이블과 자식테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 자금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다.

  

- 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수도 있다. 물론 부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제 없이 실행할 수 있지만, 외래 키가 복잡하게 얽힌 경우에는 그렇게 간단하지 않다.

  - 서비스에 문제가 있어 긴급하게 뭔가 조치를 해야하는데 이런 문제가 발생하면 더 조급해질 수도 있다.

    - __이런 경우, foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.__

      - 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠르게 처리할 수 있다.

      ```mysql
      > SET foreign_key_checks=OFF;
      ```

    

  - 외래 키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 간의 관계가 깨진 상태로 그대로 유지해도 된다는 것을 의미하지는 않는다.

    - __외래키 체크를 일시적으로 중지한 상태에서 외래 키 관계를 가진 부모 테이블의 레코드를 삭제했다면, 반드시 자식 테이블의 레코드도 삭제해서 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화해야 한다.__

      

    - foreign_key_checks가 비활성화되면 외래키 관계의 부모 테이블에 대한 작업(ON DELETE CASCADE와 ON UPDATE CASCADE 옵션)도 무시하게 된다.

      

  - foreign_key_checks 시스템 변수는 적용 범위를 GLOBAL과  SESSION  모두로 설정 가능한 변수다.

    - 이런 작업을 할 떄는 현재 작업을 실행하는 세션에서만 외래 키 체크 기능을 멈추게 해야 한다.

      

    - SESSION  키워드를 명시하지 않으면 자동으로 현재 세션의 설정만 변경하기 때문에 다음 두 명령은 동일한 효과를 낸다. 

    ```mysql
    > SET foreign_key_checks=OFF;
    > SET SESSION foreign_key_checks=OFF;
    ```



<br>

***

### MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능

  

- 잠금을 사용하지 않는 일관된 읽기를 제공하는데에 가장 큰 목적이 있다.

  

- InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현하는데 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

  

- 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

  

- 격리 수준(Isolation Level)이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 확인해 보자.



```sql
CREATE TABLE memeber (
	m_id 		INT NOT NULL,
  m_name	VARCHAR(20) NOT NULL,
  m_area  VARCHAR(100) NOT NULL,
  PRIMARY KEY(m_id),
  INDEX ix_area (m_area)
)

INSERT INTO member(m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
COMMIT:
```

- INSERT 문이 실행되면 데이터베이스의 상태는 아래와 같이 바뀐다.

![스크린샷 2021-11-29 오전 10 29 32](https://user-images.githubusercontent.com/50399804/147019581-89f11780-3699-45fc-9b2c-601f11b246f8.png)



- member 테이블에 UPDATE 문장이 실행될 때는 아래와 같이 변경 된다.

```sql
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```

![KakaoTalk_Photo_2021-11-29-10-28-31](https://user-images.githubusercontent.com/50399804/147019968-879f2583-4a50-412b-abe9-d9c902d8ae42.jpeg)

- UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀ㄹ은 새로운 값이 '경기'로 업데이트된다.

  

- 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 있고 아닐 수도 있다.

  (InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방하다)

  

- 아직 Commit 되지 않은 상태에서 레코드를 조회하면 어디에 있는 데이터를 조회할까?

  - MySQL 서버의 시스템 변수(transaction_isolation)에 설정된 격리 수준(Isolation Level)에 따라 다르다.

    - 격리 수준이 READ_COMMITED 인 경우에는 InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환한다.

      - 데이터가 Commit 되었든 아니든 변경된  상태의 데이터를 반환한다.

        

    - 그 이상의 격리 수준인 경우에는 아직 Commit되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경 하기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다, 

    

- 위와 같은 과정을 DBMS에서는 MVCC 라고 표현한다.

  - 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조를 말한다.

  

  - 한 개의 데이터로 예시를 들었지만 관리해야 하는 예전 버전의 데이터는 무한히 많아질 수 있다.

    (트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리되어야 하며, 자연히 Undo 영역이 저장되는 시스템 테이블 스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.)

  

- 지금 상태에서 Commit 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.

  - 하지만, Rollback을 실행하면 InnoDB는 UnDo 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, Undo 영역의 내용을 삭제해버린다.

    

  - Commit이 된다고 Undo 영역의 백업 데이터가 항상 바로 삭제 되는 것은 아니다. Undo 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제 된다.

  

<br>

***

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.

  

- 잠금을 걸지 않기 때문에 InnoDB 에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.

  

- 격리 수준이 SERIALIZABLE 이 아닌 다른 수준인 경우, INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 벼경 작업과 관계없이 항상 잠금을  대기하지 않고 바로 실행된다.

  

- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 읽기 작업을 방해하지 않는다.

  - 이를 '잠금 없는 일관된 읽기' 라고 표현하며, InnoDB 에서는 변경되기 전의 데이터를 읽기 위해 Undo 로그를 사용한다.

![KakaoTalk_Photo_2021-11-29-10-49-35](https://user-images.githubusercontent.com/50399804/147021344-12f32be2-49b4-428d-8ddd-3a126a02cef1.jpeg)



- 오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다.
  - 따라서 트랜잭션이 시작되었다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.



<br>

***

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.

  

- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 강제 종료한다.

  

- 이때, 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 Undo 로그 양이며, Undo 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.

  - 트랜잭션이 Undo 레코드를 적게 가졌다는 이야기는 롤백을 해도 Undo 처리를 해야 할 내용이 적다는 것이며, 트랜잭션 강제 롤백으로 인해 MySQL 서버의 부하도 덜 유발하기 때문이다.

    

- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금([LOCK TABLES 명령](https://myinfrabox.tistory.com/75)으로 잠긴 테이블)은 볼 수가 없어서 데드락 감지가 불확실할 수도 있는데, [innodb_table_locks 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_table_locks)를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금 까지 감지할 수 있게 된다.

  - 특별한 이유가 없다면 innodb_table_locks 시스템 변수를 활성화하자.

    

- 일반적인 서비스에서 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않는다.

  

- 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.

  

- 데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾게 된다.

  

- 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 된다.

  - 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

    

  - 이런 문제점을 해결하기 위해 MySQL 서버는 [innodb_deadlock_detect 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_deadlock_detect)를 제공한다.

    - OFF로 설정하면 데드락 감지 스레드는 더는 작동하지 않게 된다.

      - 작동하지 않을 경우, InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황(데드락 상황)이 발생해도 누군가가 중재를 하지 않기 때문에 무한정 대기하게 될 것이다.

        

    - 하지만 [innodb_lock_wait_timeout 시스템 변수](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout)를 활성화하면 이런 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 된다.

      - 초 단위로 설정할 수 잇으며, 잠금을 설정할 시간 동안 획득하지 못하면 쿼리는 실패하고 에러를 반환한다.

        

  - 데드락 감지 스레드가 부담되어 innodb_deadlock_detect 를 OFF 로 설정해서 비활성화하는 경우라면 innodb_lock_wait_timeout을 기본 값이 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다.



<br>

***

### 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재되어 있음

  - MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행

    

- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않음

  

- 하지만 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못 하는 경우도 발생할 수 있는데, 일단 한 번 문제가 생기면 복구하기가 쉽지 않다.

  

- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.

  - 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료되어 버린다.

    

  - 이때 MySQL 서버의 설정 파일에 [innodb_force_recovery 시스템 변수](https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery)를 설정해서 MySQL 서버를 시작해야 한다.

    - 이 설정값은 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다.

      - InnoDB의 로그 파일이 손상되었다면 6으로 설정하고 MySQL 서버를 기동

        

      - InnoDB 테이블의 데이터 파일이 손상되었다면 1로 설정하고 MySQL 서버를 기동

        

      - 어떤 부분이 문제인지 알 수 없는 경우, Innodb_force_recovery 설정 값을 1부터 6까지 변경하면서, MySQL을 재시작해 보자.

        - innodb_force_recovery 값이 커질수록 그만큼 심각한 상황이어서 데이터 손실 가능성이 커지고 복구 가능성이 적어진다.

          

- MySQL 서버가 기동이 되고, InnoDB 테이블이 인식된다면 [mysqldump](https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html) 를 이용해 데이터를 가능한 만큼 백업하고, 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.



- innodb_force_recovery 의 시스템 변수 변경을 통해 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다.

  

- 백업이 있다면 마지막 백업으로 데이터베이스를 새로 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있다.

  

- 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있다.

  

- 백업은 있지만 복제의 바이너리 로그가 없거나 손실됐다면 마지막 백업 시점까지만 복구할 수 있다.



> 바이너리 로그란?
>
> - [MySQL 공홈](https://dev.mysql.com/doc/refman/5.6/en/binary-log.html)
>
>   
>
> - https://myinfrabox.tistory.com/20

