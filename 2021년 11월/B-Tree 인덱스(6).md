## B-Tree 인덱스의 가용성과 효율성

- 쿼리의 WHERE 조건이나 GROUP BY 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고, 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.

  

- 그래야만 쿼리의 조건을 최적화하거나, 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있다.

  

- 어떤 조건에서 인덱스를 사용할 수 있고, 어떨 때 사용할 수 없는지 알아보자.

  

- 또, 인덱스를 100% 활용할 수 있는지, 일부만 이용하게 되는지도 알아 보자.

  

<br>

***

### 비교 조건의 종류와 효율성

- 다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교("=") 인지 아니면 크다(">") 또는 작다("<") 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

```sql
> SELECT * FROM dept_emp
	WHERE dept_no = 'd002' AND emp_no >= 10114;
```



- 위 쿼리를 위해 dept_emp 테이블에 각각 컬럼의 순서만 다른 2가지 케이스로 인덱스를 생성했다고 가정하자.

```
Case A : Index (dept_no, emp_no)
Case B : Index (emp_no, dept_no)
```



![KakaoTalk_Photo_2021-11-19-21-15-22](https://user-images.githubusercontent.com/50399804/145996734-831cc56a-755f-4bb4-97dd-0de626b55bc6.jpeg)

- Case A 인 경우, dept_no ='d002' AND emp_no >='10144' 인 레코드를 찾고, 그 이후에는 dept_no 가 'd002' 가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 된다.

  - 조건을 만족하는 레코드가 5건이라고 할 때, 5건의 레코드를 찾는 데 꼭 필요한 5번의 비교 작업만 수행한 것이므로 상당히 효율적으로 인덱스를 이용한 것이다.

    

- Case B 인 경우, emp_no >= 10144 AND dept_no = 'd002' 인 레코드를 찾고, 그 이후 모든 레코드에 대해 dep_no가 'd002' 인지 비교하는 과정을 거쳐야 한다.

  - 이 경우, 5건을 찾기 위해 7번의 비교 과정을 거친다.

  

- 이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링' 이라고도 한다.

  

- 다중 컬럼 인덱스에서는 정렬 방식이 인덱스의 N번째 키 값은 N-1번째 키 값에 대해서 다시 정렬되기 때문이다.

  - 그래서 Case A 인 경우, 두번째 컬럼이 비교 작업의 범위를 좁히는 데 도움을 주었지만, B는 2번째 컬럼인 dept_no 는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 못하고, 단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용 되었다.

    

- 공식적인 명칭은 아니지만 Case A 인덱스에서 같이 작업 범위를 결정하는 조건을 '작업 범위 결정 조건' 이라 하고, Case B 인덱스의 조건과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 필터링 조건 또는 체크 조건이라고 표현한다.

  

- 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능 높이지만 체크 조건은 많다고 해서 (최종적으로는 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.



<br>

***

### 인덱스의 가용성

![KakaoTalk_Photo_2021-11-19-21-15-22](https://user-images.githubusercontent.com/50399804/145998292-95260070-7fe8-44ab-a1a6-884fee4f67ea.jpeg)

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬되어 있다는 것이다. 하나의 칼럼내에서 뿐만 아니라 다중 컬럼 인덱스의 컬럼에 대해서도 적용된다.

  

  ```sql
  > SELECT * FROm employees WHERE first_name LIKE '%mer';
  ```

- A 인덱스가 사용된 테이블에서 이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수는 없다. 이유는 first_name 컬럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상수값('%mer') 에는 왼쪽 부분이 고정되지 않았기 때문이다.

  - 따라서 정렬 우선순위가 낮은 뒷부분의 값만으로는 왼쪽 기준(Left-most) 정렬 기반의 인덱스인 B-tree 인덱스에서는 인덱스의 효과를 얻을 수 없다.

    

  ```mysql
  > SELECT * FROM dept_emp WHERE emp_no >= 10144;
  ```

- B 인덱스가 사용된 테이블에서 이 쿼리를 사용하는 경우, 인덱스의 선행 컬럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.

  

- 인덱스의 왼쪽 값 기준 규칙은 GROUP BY 절이나 ORDER BY 절에도 똑같이 적용된다.



<br>

***

### 가용성과 효율성 판단

- 기본적으로 __B-Tree 인덱스의 특성상 다음 조건에서 사용할 수는 없다.__ 여기서 사용할 수 없다는 것은 작업 범위 결정 조건으로 사용할 수 없다는 것을 의미하며, 겨웅에 따라서는 체크 조건으로 인덱스를 사용할 수 있다.

  - NOT-EQUAL로 비교 된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")

    - ...WHERE column <> 'N'

      

    - ...WHERE colum NOT IN (10, 11, 12)

      

    - ...WHERE column IS NOT NULL

      

  - LIKE '%??' (앞 부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우

    - ...WHERE column LIKE '%규비'

      

    - ...WHERE column LIKE '_규비'

      

    - ...WHERE column LIKE '%규비%'

    

  - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후, 비교된 경우

    - ...WHERE SUBSTRING(column, 1, 1) = 'X'

      

    - ...WHERE DAYOFMONTH(column) = 1

      

  - NON-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

    - ...WHERE column = deterministic_function()

      

  - 데이터 타입이 서로 다른 비교 (인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)

    - ...WHERE char_column = 10

      

  - 문자열 데이터 타입의 콜레이션이 다른 경우

    - ...WHERE utf8_bin_char_column = euckr_bin_char_column

      

- 다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만, MySQL 에서는 NULL값도 인덱스에 저장된다.

  - 다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.

  ```sql
  > ...WHERE column IS NULL ...
  ```

  

- 다중 컬럼으로 만들어진 인덱스는 어떤 조건에서 사용될 수 있고, 어떤 경우에 절대 사용할 수 없는지 살펴보자.

  ```sql
  INDEX ix_test ( col1, col2, col3, .... colN )
  ```

  - 작업 범위 결정 조건으로 __인덱스를 사용하지 못하는 경우__

    - col1 컬럼에 대한 조건이 없는 경우

      

    - col1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우

      

  - 작업 범위 결정 조건으로 __인덱스를 사용하는 경우__ (i는 2보다 크고 n보다 작은 임의의 값을 의미)

    - col1 ~ col(i-1) 컬럼까지 동등 비교 형태("=" 또는 "IN")으로 비교

      

    - col(i) 컬럼에 대해 다음 연산자 중 하나로 비교

      - 동등 비교 ("=" 또는 "IN")

        

      - 크다, 작다 (">" 또는 "<")

        

      - LIKE 좌측 일치 패턴  (LIKE '규비%')



- 인덱스를 사용하는 겨웅와 그렇지 않은 상황에 해당하는 쿼리의 조건을 몇 가지 살펴보자.

```sql
-- 인덱스 사용 불가
> ...WHERE col1 <> 2

-- col1, col2 까지 범위 결정 조건으로 사용
> ...WHERE col1 = 1 AND col2 > 10

-- col1, col2, col3 까지 범위 결정 조건으로 사용
> ...WHERE col1 IN (1,2) AND col2 = 2 AND col3 <= 10

-- col1, col2, col3 까지 범위 결정 조건으로, col4 는 체크 조건으로 사용됨
> ...WHERE col1 = 1 AND col2 = 2 AND col3 IN (10, 20, 30) AND col4 <> 100

-- col1, col2, col3, col4 까지 범위 결정 조건으로 사용됨
-- 좌측 패턴일치 LIKE 비교는 크다 또는 작다 비교와 동급으로 생각하면 됨
> ...WHERE col1 = 1 AND col2 IN (2,4) AND col3 = 30 AND col4 LIKE '김승%'

-- col1, col2, col3, col4, col5 컬럼까지 모두 범위 결정 조건으로 사용됨
> ...WHERE col1 = 1 AND col2 = 2 AND col3 = 30 AND col4 = '조규비' AND col5 = '서울'
```

