## B-Tree 인덱스 

> B 마이너스가 아니니 잘못읽지 말자

- 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다.

  - 가장 범용적인 목적으로 사용되는 인덱스 알고리즘이다.

    

- 여러 가지 변형된 형태의 알고리즘이 있는데, 일반적으로 DBMS에서는 주료 B+ Tree, B* Tree 가 사용된다.

  

- 구조 탓에 B를 Binary(이진)이라고 알고 있는 사람이 많은데, Balanced 를 의미한다는 점에 주의하자.

  

- 컬럼의 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

  - 저문 검색과 같은 특수한 요건이 아닌경우, 대부분 인덱스는 거의 B-Tree 를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.



<br>

***

### 구조 및 특성

![balanced-tree1](https://user-images.githubusercontent.com/50399804/145752729-9b6001f9-1aed-45eb-9904-4f3f97f30810.png)

- 트리 구조의 최상위에 하나의 루트 노드(Root Node)가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태이다.

  

- 트리 구조에서 중간에 있는 노드를 브런치 노드(Branch Node)라고 하고, 최하단에 있는것을 리프 노드(Leaf Node) 라고 한다.

  

- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.

  

- 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다.

  - 테이블의 레코드를 전혀 삭제하거나 변경하지 않고, INSERT 만 수행한다면 데이터 파일의 레코드가 INSERT된 순서대로 저장되어 있을 수 있지만,

    레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT 는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되는 것은 아니다.



> 대부분의 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고, 임의의 순서로 저장된다.
>
> 하지만, InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
>
> 오라클의 IOT(Index organized Table) 이나 MS-SQL의 클러스터 테이블과 같은 구조를 말한다. 다른 DBMS에서는 클러스터링 기능이 선택 사항이지만,
>
> InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다.
>
> 클러스터링이란 비슷한 값을 최대한 모아서 저장하는 방식을 의미한다.



- 인덱스는 테이블의 키 걸럼만 가지고 있으므로, 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
  - 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가지므로 다음 그림과 같이 찾아간다.

![KakaoTalk_Photo_2021-12-13-13-39-07](https://user-images.githubusercontent.com/50399804/145753354-a559d7f1-ea0c-4174-8f20-9035fa5f1a95.jpeg)

- InnoDB 테이블에서는 인덱스를 통해, 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다.

  

- InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스를 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

  - 이 작업으로 인해 InnoDB 스토리지 엔진을 사용하는 테이블은 성능이 떨어지는 것처럼 보이지만, 사실은 각 엔진의 인덱스 구조마다 각각 장단점이 있다고 한다.

    - 이에 대해서는 클러스터링 인덱스로 후술하겠다.

      

<br>

***

### B-Tree 인덱스 키 추가 및 삭제

- 테이블의 레코드를 저장하거나 변경하는 경우, 인덱스 키 추가나 삭제 작업이 발생한다. 인덱스 키 추가나 삭제가 어떻게 처리되는지 알아두면 쿼리의 성능을 쉽게 예측할 수 있다.

  

- __인덱스 키 추가__

  - 새로운 키 값이 B-Tree 에 저장될 떄 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고, 그렇지 않을 수도 있다.

    

  - B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다.

    

  - 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.

    

  - 리프 노드가 꽉 차서 더는 저장할 수는 없을 때는 리프 노드가 분리되어야 하는데, 이는 상위 브런치 노드까지 처리의 범위가 넓어진다.

    

  - 이러한 작업 탓에 B-Tree 는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려져 있다. 

    

  - 인덱스의 추가로 인해 INSERT 나 UPDATE 문장이 어떤 영향을 받을지 궁금해 질 수 있는데, 이 질문에 대답하려면 테이블의 컬럼 수, 컬럼의 크기, 인덱스 컬럼의 특성등을 확인해야 한다.

    - 대략적으로 계산하는 방법은 테이블의 레코드를 추가하는 작업 비용을 1이라고 가정ㅇ하면, 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5로 예측하는 것이다.

      - 일반적으로 테이블에 인덱스가 3개라면 (모두 B-Tree), 이때 테이블에 인덱스가 하나도 없는 경우는 작업 비용이 1이고, 3개인 경우엔 5.5 정도의 비용 (1.5 * 3 + 1) 정도로 예측한다.

        

      - 중요한 것은, 이 비용의 대부분이 메로리와 CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이라는 점이다.



> MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면, 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
>
> InnoDB 스토리지 엔진은 이 작업을 조금 더 지능적으로 처리하는데, 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
>
> 하지만 PK 나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.



<br>

***

### 인덱스 키 삭제

- B-Tree의 키 값이 삭제되는 경우는 상당히 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.

  - 이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.

    

- 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로, 이 작업 역시 디스크 I/O가 필요한 작업이다.

  - MySQL 5.5 이상의 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수도 있다.

    

  - 처리가 지연된 인덱스 키 삭제 또한 사용자에게는 특별한 악영향 없이 MySQL 서버가 내부적으로 처리하므로 특별히 걱정할 것은 없다.

    

  - MyISAM이나 MEMORY 스토리지 엔진의 테이블에서는 체인지 버퍼와 같은 기능이 없으므로, 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.



> 체인지 버퍼란?
>
> - 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.
>
>   - 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 상당히 많은 작업을 소모하게 된다.
>
>     
>
>   - InnoDB 는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 즉시 실행하지 않고, 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상하게 되는데, 이때 사용하는 임시 메모리 공간을 체인지 버퍼라고 한다.
>
>     
>
> - 단, 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
>
>   - 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드라고 한다.
>
> 
>
> 출처 https://willseungh0.tistory.com/155



>  참조 Real MySQL 8.0